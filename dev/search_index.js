var documenterSearchIndex = {"docs":
[{"location":"gettingstarted/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"The dynamic stall models are implemented in three ways: as a functional, an iterative, and in an indicial form. ","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Functional implementations create a struct that returns the state rates. This allows for easy solution using DifferentialEquations.jl. These functional implementations are designed to be passed a single set of parameters, p. Out of this set of parameters, several are functions, such as the freestream velocity. ","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Iterative implementations create a struct that returns the state rates as well, however they are not as easily solved by DifferentialEquations.jl. The input parameters are now all constant values, including the freestream velocity and angle of attack. This implementation is designed to be solved iteratively, meaning that for a given set of parameters, the states are updated for a single time step. The purpose of this type of implementation is for interfacing with other packages, specifically Rotors.jl. In the future, a function will be introduced that converts functions that describe environmental inputs into parameters, and then iterates through the solution of the model. ","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"The final implementation is an indicial formulation. Rather than providing a state space model to be solve, the model takes the environmental inputs and time step and calculates the states at the next time step. Several of the dynamic stall models included in this pakage were first developed in indicial form. ","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"We'll get started by using a functional implementation of the Risø model. Because we are using a functional implementation, we willl need our flow conditions as functions of time. We'll simulate a flat plate pitching in steady inflow. We'll look at a freestream velocity of 1 m/s, while the airfoil pitches plus or minus 1 degree (amplitude of 2) about 5 degrees. ","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"k = 0.2 #reduced frequency\nu = 1.0 #freestream velocity (m/s) \nc = 1.0 #Chord (m)\namplitude = 2\nshift = 5\n\nomega = k*2*u/c #Rate of oscillation\n\n### Prepare inputs\nU(t) = u #Freestream velocity as a function of time\nUdot(t) = 0.0 #Derivative of freestream velocity as a function of time\nalpha(t) = (amplitude*sin(omega*t) + shift)*(pi/180) #Angle of attack as a function of time (radians)\nalphadot(t) = (amplitude*omega*cos(omega*t)*(pi/180)) #Pitching rate as a function of time (radians)","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"At this point, we would normally read in an airfoil polar, however, since we are simulating a flat plate, we will use the inviscid solution for lift for a flat plate. ","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"\naoa = -pi:0.01:pi #Angle of Attack, (radians)\nlift = 2*pi.*(aoa) #Coefficient of lift\ndrag = zero(aoa) #Coefficient of drag, left zero for this demonstration. \npolar = hcat(aoa, lift, drag)\n\nA = [0.165, 0.335] #From the Hansen 2004 paper, for flat plate\nb = [0.0455, 0.3000] # \"\" \"\"\n\nTp = 3.0 # \"\" \"\" \nTf = 6.0 # \"\" \"\" \nT = [Tp, Tf]","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Now at this point, we'll store that information in an airfoil struct. ","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"using DynamicStallModels\n\nairfoils = [airfoil(polar; A, b, T)]","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"If we had more airfoils, we would simply add them to the airfoils array. ","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Now we'll create the Risø struct, which will be our ODE to solve. ","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"dsmodel = Riso(airfoils; detype=Functional())","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"And now we prepare to solve using DifferentialEquations.jl. Note the order of p below, this is the required order. If simulating more than one airfoil, the chord lengths would be concatonated. So p = vcat([U, Udot, alpha, alphadot], [c]).","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"using DifferentialEquations\nx0 = zeros(4) #Hansen 2004's suggest initial conditions.\nx0[3] = 1.0\n\np = [U, Udot, alpha, alphadot, c]\n\ntspan = (0.0, 80.0)\n\nprob = ODEProblem(dsmodel, x0, tspan, p)","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Now let's solve using DifferentialEquations. A function to parse the DifferentialEquations solution and calculate the coefficients of lift and drag has been provided. ","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"sol = solve(prob, dtmax=0.1)\n\nCl, Cd, t =  parsesolution(dsmodel, sol, p)","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Also if the user has a specific set of states they would like to analyze, they can extract the states on their own and use the provided functions to calculate the coefficients. ","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"### Unpack\nx = Array(sol)'\nt = sol.t\n\nnt = length(t)\n\nclvec = zeros(nt, dsmodel.n)\ncdvec = zeros(nt, dsmodel.n)\n### run through the time steps and calculate the dynamic lift and drag (based on the states)\nfor i = 1:nt\n    ti = t[i]\n    for j = 1:dsmodel.n\n        clvec[i,j], cdvec[i,j] = riso_coefficients(x[i,:], U(ti), alpha(ti), alphadot(ti), cvec[j], dsmodel.airfoils[j])\n    end\nend","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Here we use Plots.jl to visualize the lift and compare against the values given in Hansen's 2004 paper where the model was presented. Note that shown is Hansen's indicial solution, whereas here we solve the state space model, so minor differences exist. ","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"using Plots\nalphavec = alpha.(sol.t)\n\nexpdata = readdlm(\"./data/Hansen2004/figure8_flatplate/indicial.csv\", ',')\n\n\nclplt = plot(legend=:topleft, title=\"Cyclic Alpha\", yaxis=\"Cl\", xaxis=\"Alpha (deg)\")\nscatter!(expdata[:,1], expdata[:,2], lab=\"Hansen 2004\")\nplot!(alphavec.*(180/pi), Cl, lab=\"DSM - Riso\")\nplot!(alphavec.*(180/pi), linearlift.(alphavec), lab=\"Static\")\ndisplay(clplt)","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"beddoesleishman_theory/#Beddoes-Leishman-Theory","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"","category":"section"},{"location":"beddoesleishman_theory/#State-Rate-Equations","page":"Beddoes-Leishman Theory","title":"State Rate Equations","text":"","category":"section"},{"location":"beddoesleishman_theory/#Under-Construction","page":"Beddoes-Leishman Theory","title":"Under Construction","text":"","category":"section"},{"location":"beddoesleishman_theory/#Equations","page":"Beddoes-Leishman Theory","title":"Equations","text":"","category":"section"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"reduced linear lift coefficient - high frequency (or low, don't know which) (EQ 13)","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"dotc_1 + omega_1 c_1(t) = A_1 dotC_L0(t)","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"reduced linear lift coefficient - low frequency (EQ 13)","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"dotc_2 + omega_2 c_2(t) = A_2 dotC_L0(t)","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"impulsive contributions diminishing in time due to wave propagation. (EQ A.2)","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"dotc_3 + omega_5 c_3(t) = frac4MA_3dotalpha","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"''   ''   ''   ''   ''   ''   ''  (EQ A.2)","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"dotc_4 + omega_6 c_4(t) = frac1MA_4fraccVddotalpha","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"The retarded linear lift C_L0d(t)​​  is introduced as a delayed state variable of the linear lift C_L0d(t)​​​, which gives a one-to-one correspondence between the pressure coefficient and the dynamic lift at changing pitch rates (EQ A.3)","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"dotC_L0d(t) = -omega_7bigg(C_L0d(t) - C_L0d(t)bigg)","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"Which when you plug everything in, then you get a  different equation: (EQ A.5)","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"dotC_L0d(t) = omega_7bigg(-c_1(t) - c_2(t) + c_3(t) + c_4(t) - C_L0d(t) + C_L0(alpha)bigg)","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"dynamic attachment degree (EQ 16)","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"dotf_d = - omega_3 bigg(f_d(t)-f(alpha)bigg)","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"Leading edge vortex contribution (EQ 22)","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"dotC_Lv(t) + omega_4 C_Lv(t) = \nbegincases\nDelta dotC_L(t) quad textrmfor quad tau  1 hspace3pt textrmand hspace3pt dotalpha0 \n0 hspace38pt textrmotherwise\nendcases","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"Time Constant** (EQ 21)","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"dottau = \nbegincases\nfracV3c quad textrmfor quad alphaalpha_v\n0 quad textrmotherwise\nendcases","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"** This state variable was not included in the original formulation, however, they included a time constant tau that was the position of the leading edge vortex, and it moves with a speed of dottau​​, so I figured, I'd make it a state variable that was really simple. Let the solver manage that information. I don't think that I could write something to manage it better. ","category":"page"},{"location":"beddoesleishman_theory/#Indicial-Formulation-(Original)","page":"Beddoes-Leishman Theory","title":"Indicial Formulation (Original)","text":"","category":"section"},{"location":"beddoesleishman_theory/#Under-Construction-2","page":"Beddoes-Leishman Theory","title":"Under Construction","text":"","category":"section"},{"location":"beddoesleishman_theory/#Indicial-Formulation-(AeroDyn)3","page":"Beddoes-Leishman Theory","title":"Indicial Formulation (AeroDyn)^3","text":"","category":"section"},{"location":"beddoesleishman_theory/#Under-construction","page":"Beddoes-Leishman Theory","title":"Under construction","text":"","category":"section"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"AeroDyn has it's own implementation of the Beddoes-Leishman model, with several variations here and there. I will not go through the theory here, as you can reference the original document. Note that the code is slightly different from the theory documentation. Some differences between the theory document and software include:","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"Several calculations are used that are claimed to be more stable than the original theory (see the OpenFAST code).\nThere are separate separation point and associated deficiency functions for the normal, chordwise, and moment loads. \nThere are values stored with the states that aren't labeled as states.","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"What I have implemented isn't quite the same as what AeroDyn presents in their theory document, but it produces the same loads (<0.01%, <0.05% relative error for the normal, tangential, and moment loads respectively) as OpenFAST v3.3.0. ","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"Some of the differences between my code and OpenFAST v3.3.0 include:","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"I don't differentiate between other states and the continuous states. \nI omit several states that don't need to be states. \nI reorganize the states for readability. \nThere are some simple unstated values that I assume. ","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"If you want to see the exact algorithm that I implement, check out the code. ","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"AeroDyn also has several different versions that you can change between. The theory is also presented in the theory document mentioned above. Note that states and other variables change with the modifications (as expected). The different versions I have are:","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"Original (Under construction)\nGonzalez (Validated)","category":"page"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"1) @article{Leishman1989,\n\tAuthor = {J. G. Leishman and T. S. Beddoes},\n\tJournal = {Forum of the American Helicopter Society},\n\tTitle = {A Semi-Emprical Model for Dynamic Stall},\n\tVolume = {42},\n\tYear = {1989}}\n\n2) @article{Hansen2004,\n\tAuthor = {Morten Hartvig Hansen and Mac Gaunaa and Helge Aa. Madsen},\n\tJournal = {Riso National Laboratory},\n\tTitle = {A Beddoes-Leishman type dynamic stall model in state-space and indicial formulations},\n\tYear = {2004}}\n\n3) @techreport{Damiani2019,\n\tAuthor = {Rick Damiani and Greg Hayman},\n\tInstitution = {NREL},\n\tTitle = {The Unsteady Aerodynamics Module for FAST 8},\n\tYear = {2019}}\n","category":"page"},{"location":"riso_theory/#Risø-Theory","page":"Risø Theory","title":"Risø Theory","text":"","category":"section"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"The Risø model^2 is a simplified version of the Beddoes-Leishman model, designed specifically for wind turbines.","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"It has four states. The four states are:","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"Variable Name Comments\nx_1  Using Theodorsen theory, we can come up with two ODEs to describe the change in the wake.\nx_2  The first state and second state model these changes. One is for high frequency changes while the other is for low frequency changes.\nx_3 = C_L^p Delayed coefficient of lift due to pressure. Delayed unsteady attached lift coefficient. A simple time lag (first order lag) between the pressure field and the lift.\nx_4 = f Delayed seperation point? Unsteady seperation point. This should range (0,1).","category":"page"},{"location":"riso_theory/#State-Rate-Equations","page":"Risø Theory","title":"State Rate Equations","text":"","category":"section"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"beginaligned\ndotx_1 = - fracx_1T_uleft(b_1 + fraccdotU2U^2right) + fracb_1A_1 alpha_34T_u \ndotx_2 = - fracx_2T_uleft(b_2 + fraccdotU2U^2right) + fracb_2A_2 alpha_34T_u \ndotx_3 = - fracx_3T_p + frac1T_pleft(fracpartial C_lpartial alpha(alpha_E - alpha_0) + pi T_u dotalpha right) \ndotx_4 = - fracx_4T_f = frac1T_ff^stleft(alpha_fright)\nendaligned","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"where x_i are the states of the model, T_x are time constants, A_i and b_i are airfoil specific constants describing the response of the airfoil, U is the freestream velocity, alpha_34 is the angle of attack the three-quarter point, fracpartial C_lpartial alpha is the slope of the static lift curve in the linear region, alpha_E is the equivalent angle of attack, f^st is the seperation point function, and alpha_f is the delayed angle of attack (this is something that I made up to make the notation a little clearer. ). ","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"A couple of notes: first, T_u is calculated, whereas the other two time constants are specific for the airfoil (although several authors have said that they are pretty constant from airfoil to airfoil... but at the same time, those authors give different values for the time constant than the other authors... so it seems pretty arbitrary). Second, variables with a dot above it (dotU for instance) indicate the derivative with respect to time. Third, recognize that U and alpha are both functions of time. Fourth, I just use the angle of attack for alpha_34... which appears to work, but Hansen's paper specifically seperates from the geometric angle of attack.","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"Now I'm going to dive into a bunch of the functions. ","category":"page"},{"location":"riso_theory/#First-Time-Constant","page":"Risø Theory","title":"First Time Constant","text":"","category":"section"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"T_u = fracc2U","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"where c is the chord, and U is the freestream velocity. Since U is a function of time, then this time constant isn't really constant...","category":"page"},{"location":"riso_theory/#Lift-Curve-Slope","page":"Risø Theory","title":"Lift Curve Slope","text":"","category":"section"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"Hansen gives an equation for fracpartial C_lpartial alpha, which makes it so that f^st never goes over 1.... which is just a max equation... but I feel like it is a lame excuse and it is more accurate if you use a value that matches the majority of the linear region. I feel like there should be a better way to define f^st so it never goes over 1, and plays nicely with optimization. At the same time he says: \"However, in cases where lift curves are provided directly from measurements, or CFD computations, it can be necessary to use linear regression to determine a linear lift curve in a range of lower angles of attack with fully attached flow.\" DG has said several times that it is fairly common to choose constants that recreate the static lift curve. ","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"fracpartial C_lpartial alpha = textmaxleft(fracC_l^st(alpha)(alpha - alpha_0)right)","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"where C_l^st is the lift from the static lift curve, and alpha_0 is the zero lift angle of attack. You'll frequently see fracpartial C_lpartial alphaleft(alpha - alpha_0right), which is just the inviscid lift. Note that in his paper, Hansen denotes the linear lift curve slope as C_Lalpha. ","category":"page"},{"location":"riso_theory/#Equivalent-Angle-of-Attack","page":"Risø Theory","title":"Equivalent Angle of Attack","text":"","category":"section"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"alpha_E = alpha_34(1 - A_1 - A_2) + x_1 + x_2","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"It's an equivalent angle of attack. Basically from what I understand is it is a weighting of what we expect the angle of attack to be from the geometric angle of attack and what the wake currently looks like.","category":"page"},{"location":"riso_theory/#Seperation-Point-Function","page":"Risø Theory","title":"Seperation Point Function","text":"","category":"section"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"Here is a function that gives me a little bit of problem:","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"f^st(alpha) = left(2 sqrtfracC_l^stC_l^i -1right)^2","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"where C_l^i is the inviscid lift coefficient. The inviscid lift coefficent, as previously mentioned, is simply: C_l^i(alpha) = fracpartial C_lpartial alpha (alpha - alpha_0). However, the value of this should always be on the range (0,1). It should be equal to 1 when the flow is fully attached (in the linear region), and 0 when the angle of attack is outside the angles of full seperation. Hansen defines the angles of full seperation as when the static lift is one-fourth the value of the inviscid lift:","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"C_l^st(alpha^pm fs) = leftfracpartial C_lpartial alphafrac(alpha^pm fs - alpha_0)4right","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"What I currently have implemented for the seperation pooint function is: ","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"f^st(alpha)=begincases\n          0 quad textif   alphaalpha^-fs  alphaalpha^+fs \n          1 quad textif   f^st  1    f^st = textNaN \n          left(2 sqrtfracC_l^stC_l^i -1right)^2 quad  textelse\n     endcases","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"Which isn't my favorite. But it works. ","category":"page"},{"location":"riso_theory/#Other-Time-Constants","page":"Risø Theory","title":"Other Time Constants","text":"","category":"section"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"T_f","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"describes the time lag in the boundary layer. ","category":"page"},{"location":"riso_theory/#Equations-for-the-Coefficients","page":"Risø Theory","title":"Equations for the Coefficients","text":"","category":"section"},{"location":"apireference/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"As you will see in the Code Outline and getting started, most of the code in this package revolves around creating instances of model, which have been formatted to be solved. There are some convenience functions for creating these structs. There are also some functions for parsing solutions. another change. another change. ","category":"page"},{"location":"apireference/#Airfoils","page":"API Reference","title":"Airfoils","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"DynamicStallModels.Airfoil","category":"page"},{"location":"apireference/#DynamicStallModels.Airfoil","page":"API Reference","title":"DynamicStallModels.Airfoil","text":"Airfoil(polar::Array{TF, 2}, cl::Tfit, cd::Tfit, cm::Tfit, dcldalpha::TF, alpha0::TF, alphasep::Array{TF, 1}, A::Array{TF, 1}, b::Array{TF, 1}, T::Array{TF, 1})\n\nA struct to hold all of the airfoil polars, fits, and dynamic coefficients. \n\nInputs\n\npolar - A matrix of floats describing the airfoil polar. This includes the angle of attack (radians), and coefficients of lift, drag, and moment. \ncl - A fit of the coefficient of lift as a function of the angle of attack (radians). \ncd - A fit of the coefficient of drag as a function of the angle of attack (radians). \ncm - A fit of the coefficient of moment as a function of the angle of attack (radians). \ndcldalpha - The lift curve slope in the linear region (1/radians). Typically near 2 pi. \nalpha0 - The zero lift angle of attack (radians). \nalphasep - A vector of floats holding the angles of attack at which flow fully seperates from the airfoil. In order from least to greatest. \nA - A vector of floats holding the A dynamic constants for the airfoil. \nb - A vector of floats holding the b dynamic constants for the airfoil. \nT - A vector of floats holding the time constants for the airfoil. \nS - A vector of floats holding the S constants are best fit constants for the separation point curve. \ns - A fit of the the separation point curve. \nxcp - The distance from the quarter chord to the center of pressure? \n\n\n\n\n\n","category":"type"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"simpleairfoil","category":"page"},{"location":"apireference/#DynamicStallModels.simpleairfoil","page":"API Reference","title":"DynamicStallModels.simpleairfoil","text":"simpleairfoil(polar::Array{TF, 2})\n\nA function that takes a simple airfoil polar to make a dynamic airfoil. The function assumes that the lift curve slope is 2 pi, that the zero lift angle of attack is zero, and uses AeroDyn's default dynamic airfoil coefficients. The seperation angles of attack are the angles of attack at the minimum and maximum lift.\n\nInputs\n\npolar - A simple airfoil polar including alpha, lift, and drag.\n\nOutputs\n\nAirfoil\n\n\n\n\n\n","category":"function"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"airfoil","category":"page"},{"location":"apireference/#DynamicStallModels.airfoil","page":"API Reference","title":"DynamicStallModels.airfoil","text":"airfoil(polar::Array{TF, 2}; A::Array{TF, 1} = [0.3, 0.7], b::Array{TF, 1} = [0.14, 0.53], T::Array{TF, 1} = [1.7, 3.0])\n\nA slightly more complex version of simpleairfoil. Takes a polar and numerically finds some characteristics. \n\nInputs\n\npolar - A matrix of floats describing the airfoil polar. This includes the angle of attack (radians), and coefficients of lift, drag, and moment.\nA - A vector of floats holding the A dynamic constants for the airfoil. \nb - A vector of floats holding the b dynamic constants for the airfoil. \nT - A vector of floats holding the time constants for the airfoil. \nseparationpointfit - An integer telling which fit function to use. 1 -> AeroDyn Cn separation point function, \n\nOutputs\n\nAirfoil\n\n\n\n\n\n","category":"function"},{"location":"apireference/#Beddoes-Leishman","page":"API Reference","title":"Beddoes-Leishman","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"BeddoesLeishman","category":"page"},{"location":"apireference/#DynamicStallModels.BeddoesLeishman","page":"API Reference","title":"DynamicStallModels.BeddoesLeishman","text":"BeddoesLeishman(detype::DEType, n::Int, airfoils::Array{Airfoil, 1}, version::Int)\n\nThe Beddoes-Leishman model struct. It stores airfoil data for every section to be simulated. It can be used as a method to return updated states or state rates depending on it's DEType. \n\nInputs\n\ndetype - The type of model it is, Functional(), Iterative(), or Indicial().\nn - The number of sections to be simulated. \nairfoils - A vector of Airfoil structs, one corresponding to each section to be simulated. \nversion - Which version of the indicial implementation. 1) original. 2) AeroDyn original. 3) AeroDyn Gonzalez. 4) AeroDyn Minema\n\n\n\n\n\n","category":"type"},{"location":"apireference/#Larsen","page":"API Reference","title":"Larsen","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"Larsen","category":"page"},{"location":"apireference/#Onera","page":"API Reference","title":"Onera","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"Onera","category":"page"},{"location":"apireference/#Oye","page":"API Reference","title":"Oye","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"Oye","category":"page"},{"location":"apireference/#DynamicStallModels.Oye","page":"API Reference","title":"DynamicStallModels.Oye","text":"Oye(detype::DEType, n::Int, airfoils::Array{Airfoil, 1})\n\nThe Øye model struct. It stores airfoil data for every section to be simulated. It can be used as a method to return updated states or state rates depending on it's DEType. \n\nInputs\n\ndetype - The type of model it is, Functional(), Iterative(), or Indicial().\nn - The number of sections to be simulated. \nairfoils - A vector of Airfoil structs, one corresponding to each section to be simulated. \n\n\n\n\n\n","category":"type"},{"location":"apireference/#Risø","page":"API Reference","title":"Risø","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"Riso","category":"page"},{"location":"apireference/#DynamicStallModels.Riso","page":"API Reference","title":"DynamicStallModels.Riso","text":"Riso(detype::DEType, n::Int, airfoils::Array{Airfoil, 1})\n\nThe Risø model struct. It stores airfoil data for every section to be simulated. It can be used as a method to return updated states or state rates depending on it's DEType. \n\nInputs\n\ndetype - The type of model it is, Functional(), Iterative(), or Indicial().\nn - The number of sections to be simulated. \nairfoils - A vector of Airfoil structs, one corresponding to each section to be simulated. \n\n\n\n\n\n","category":"type"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"riso","category":"page"},{"location":"apireference/#DynamicStallModels.riso","page":"API Reference","title":"DynamicStallModels.riso","text":"riso(airfoils::Array{Airfoil, 1}; detype::DEType=Iterative())\n\nA convenience. constructor for the Risø model. \n\nInputs\n\nairfoils - A vector of Airfoil structs, one corresponding to each section to be simulated. \ndetype - The DEType of the model. Defaults to Iterative(). \n\n\n\n\n\n","category":"function"},{"location":"beddoesleishman_example/#Beddoes-Leishman","page":"Beddoes-Leishman","title":"Beddoes-Leishman","text":"","category":"section"},{"location":"beddoesleishman_example/#Original-and-State-Space-Implementations","page":"Beddoes-Leishman","title":"Original and State Space Implementations","text":"","category":"section"},{"location":"beddoesleishman_example/","page":"Beddoes-Leishman","title":"Beddoes-Leishman","text":"These implementations are still under construction. ","category":"page"},{"location":"beddoesleishman_example/#AeroDyn-Implementations","page":"Beddoes-Leishman","title":"AeroDyn Implementations","text":"","category":"section"},{"location":"beddoesleishman_example/","page":"Beddoes-Leishman","title":"Beddoes-Leishman","text":"This model is also indicial form, so it will behave similarly to all the other indicial implementations. There are some key differences in this implementation from the original implementation, and they are noted in the theory tab. ","category":"page"},{"location":"beddoesleishman_example/","page":"Beddoes-Leishman","title":"Beddoes-Leishman","text":"Since this same model is implemented in AeroDyn, we use OpenFASTsr.jl and some AeroDyn inputs and outputs to compare against. First we'll read in information about the airfoil. ","category":"page"},{"location":"beddoesleishman_example/","page":"Beddoes-Leishman","title":"Beddoes-Leishman","text":"using DynamicStallModels, OpenFASTsr\nof = OpenFASTsr\ndu21_a17 = of.read_airfoilinput(\"../../../data/DU21_A17.dat\")\naf = of.make_dsairfoil(du21_a17)","category":"page"},{"location":"beddoesleishman_example/","page":"Beddoes-Leishman","title":"Beddoes-Leishman","text":"Now we create a vector of airfoils. Here we will only test a single airfoil, so we will store that lone airfoil in a vector. ","category":"page"},{"location":"beddoesleishman_example/","page":"Beddoes-Leishman","title":"Beddoes-Leishman","text":"airfoils = Array{Airfoil, 1}(undef, 1)\nairfoils[1] = af","category":"page"},{"location":"beddoesleishman_example/","page":"Beddoes-Leishman","title":"Beddoes-Leishman","text":"Next we create an instance of the model that we want to simulate. We'll use Beddoes-Leishman, with Gonzalez's modifications (the third model). ","category":"page"},{"location":"beddoesleishman_example/","page":"Beddoes-Leishman","title":"Beddoes-Leishman","text":"dsmodel = BeddoesLeishman(Indicial(), 1, airfoils, 3)","category":"page"},{"location":"beddoesleishman_example/","page":"Beddoes-Leishman","title":"Beddoes-Leishman","text":"Now we need some inflow information. We'll use information that is passed to the unsteady module in OpenFAST. We need the inflow velocity and relative angle of attack for every time step of our simulation. ","category":"page"},{"location":"beddoesleishman_example/","page":"Beddoes-Leishman","title":"Beddoes-Leishman","text":"using DelimitedFiles\nfullout = readdlm(\"../../../data/aerodynout_fordynamicstall.csv\", ',')\nnames = fullout[1,:]\nnames[1] = \"Time\"\ndata = Float64.(fullout[3:end,:])\n\nouts = Dict(names[i] => data[:,i] for i in 1:length(names)) \n\ntvec = outs[\"Time\"]\nnt = length(tvec)\n\nUvec = [sqrt(outs[\"AB1N011Vx\"][i]^2 + outs[\"AB1N011Vy\"][i]^2) for i in 1:nt] #m/s\naoavec = outs[\"AB1N011Alpha\"].*(pi/180)","category":"page"},{"location":"beddoesleishman_example/","page":"Beddoes-Leishman","title":"Beddoes-Leishman","text":"Before we can solve the time series, we need the chord length. Here we'll assume the length is 1m. Then we can solve. ","category":"page"},{"location":"beddoesleishman_example/","page":"Beddoes-Leishman","title":"Beddoes-Leishman","text":"c = 1.0\n\nstates, loads = solve_indicial(dsmodel, [c], tvec, Uvec, aoavec)","category":"page"},{"location":"beddoesleishman_example/","page":"Beddoes-Leishman","title":"Beddoes-Leishman","text":"Now we can visualize the outputs using Plots. ","category":"page"},{"location":"beddoesleishman_example/","page":"Beddoes-Leishman","title":"Beddoes-Leishman","text":"Cn = loads[:,1] #The columns of loads are Cn, Cc, Cl, Cd, Cm\n\nusing Plots, LaTeXStrings\n\ncnplt = plot(xaxis=\"Time (s)\", yaxis=L\"C_n\")\nplot!(tvec, Cn, lab=\"BL_AD\")\nplot!(tvec, outs[\"AB1N011Cn\"], linestyle=:dash, lab=\"OpenFAST\")\ndisplay(cnplt)","category":"page"},{"location":"#DynamicStallModels.jl","page":"Introduction","title":"DynamicStallModels.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This package is a collection of different dynamic stall models. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Dynamic stall models included in this package: ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Beddoes-Leishman\nState Space \nIndicial\nAeroDyn implementation (original and Gonzalez variants)\nRisø (Hansen 2004)\nState Space\nIndicial\nLarsen\nOnera\nOye","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"To get started, add the package. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"pkg> add https://github.com/byuflowlab/DynamicStallModels.jl.git","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Then checkout the Getting Started page. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"warning: Warning - Lack of Validation\nAn important thing to note is the lack of validation. The Beddoes-Leishman implementations are very far from validated and likely still have bugs.  The Risø models perform much better. For attached conditions, the models perform as expected compare excellently to published data (see the validation section of theory (that has yet to be created)). In stall conditions, when actual stall occurs, the models do not perform as expected. We are unsure if it has something to do with our implementation, or due to a lack of information provided in the published paper. We were unable to find the operating conditions that Hansen did his simulations at, and so we assumed them. We were able to get a decent match by optimizing the dynamic coefficients, but they were much different than the ones Hansen provided.  The Onera model has been validated (The validation needs to be added). ","category":"page"},{"location":"#References","page":"Introduction","title":"References","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Please check our References page to see the original authors of content presented herein. ","category":"page"},{"location":"codeoutline/#Code-Outline","page":"Code Outline","title":"Code Outline","text":"","category":"section"},{"location":"codeoutline/","page":"Code Outline","title":"Code Outline","text":"Here I will outline the code and how it all fits together. In case you wanted to add something to this package. I expect that you've read the other documentation, as it provides important information that is required to work on this package. ","category":"page"},{"location":"riso_example/#Risø-Model","page":"Risø Model","title":"Risø Model","text":"","category":"section"}]
}
