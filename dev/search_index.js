var documenterSearchIndex = {"docs":
[{"location":"beddoesleishman_theory/#Beddoes-Leishman-Theory","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"","category":"section"},{"location":"beddoesleishman_theory/#State-Rate-Equations","page":"Beddoes-Leishman Theory","title":"State Rate Equations","text":"","category":"section"},{"location":"beddoesleishman_theory/#Under-Construction","page":"Beddoes-Leishman Theory","title":"Under Construction","text":"","category":"section"},{"location":"beddoesleishman_theory/#Equations","page":"Beddoes-Leishman Theory","title":"Equations","text":"","category":"section"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"reduced linear lift coefficient - high frequency (or low, don't know which) (EQ 13)","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"dotc_1 + omega_1 c_1(t) = A_1 dotC_L0(t)","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"reduced linear lift coefficient - low frequency (EQ 13)","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"dotc_2 + omega_2 c_2(t) = A_2 dotC_L0(t)","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"impulsive contributions diminishing in time due to wave propagation. (EQ A.2)","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"dotc_3 + omega_5 c_3(t) = frac4MA_3dotalpha","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"''   ''   ''   ''   ''   ''   ''  (EQ A.2)","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"dotc_4 + omega_6 c_4(t) = frac1MA_4fraccVddotalpha","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"The retarded linear lift C_L0d(t)​​  is introduced as a delayed state variable of the linear lift C_L0d(t)​​​, which gives a one-to-one correspondence between the pressure coefficient and the dynamic lift at changing pitch rates (EQ A.3)","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"dotC_L0d(t) = -omega_7bigg(C_L0d(t) - C_L0d(t)bigg)","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"Which when you plug everything in, then you get a  different equation: (EQ A.5)","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"dotC_L0d(t) = omega_7bigg(-c_1(t) - c_2(t) + c_3(t) + c_4(t) - C_L0d(t) + C_L0(alpha)bigg)","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"dynamic attachment degree (EQ 16)","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"dotf_d = - omega_3 bigg(f_d(t)-f(alpha)bigg)","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"Leading edge vortex contribution (EQ 22)","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"dotC_Lv(t) + omega_4 C_Lv(t) = \nbegincases\nDelta dotC_L(t) quad textrmfor quad tau  1 hspace3pt textrmand hspace3pt dotalpha0 \n0 hspace38pt textrmotherwise\nendcases","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"Time Constant** (EQ 21)","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"dottau = \nbegincases\nfracV3c quad textrmfor quad alphaalpha_v\n0 quad textrmotherwise\nendcases","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"** This state variable was not included in the original formulation, however, they included a time constant tau that was the position of the leading edge vortex, and it moves with a speed of dottau​​, so I figured, I'd make it a state variable that was really simple. Let the solver manage that information. I don't think that I could write something to manage it better. ","category":"page"},{"location":"beddoesleishman_theory/#Indicial-Formulation-(Original)","page":"Beddoes-Leishman Theory","title":"Indicial Formulation (Original)","text":"","category":"section"},{"location":"beddoesleishman_theory/#Under-Construction-2","page":"Beddoes-Leishman Theory","title":"Under Construction","text":"","category":"section"},{"location":"beddoesleishman_theory/#Indicial-Formulation-(AeroDyn)3","page":"Beddoes-Leishman Theory","title":"Indicial Formulation (AeroDyn)^3","text":"","category":"section"},{"location":"beddoesleishman_theory/#Under-construction","page":"Beddoes-Leishman Theory","title":"Under construction","text":"","category":"section"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"AeroDyn has it's own implementation of the Beddoes-Leishman model, with several variations here and there. I will not go through the theory here, as you can reference the original document. Note that the code is slightly different from the theory documentation. Some differences between the theory document and software include:","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"Several calculations are used that are claimed to be more stable than the original theory (see the OpenFAST code).\nThere are separate separation point and associated deficiency functions for the normal, chordwise, and moment loads. \nThere are values stored with the states that aren't labeled as states.","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"What I have implemented isn't quite the same as what AeroDyn presents in their theory document, but it produces the same loads (<0.01%, <0.05% relative error for the normal, tangential, and moment loads respectively) as OpenFAST v3.3.0. ","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"Some of the differences between my code and OpenFAST v3.3.0 include:","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"I don't differentiate between other states and the continuous states. \nI omit several states that don't need to be states. \nI reorganize the states for readability. \nThere are some simple unstated values that I assume. ","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"If you want to see the exact algorithm that I implement, check out the code. ","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"AeroDyn also has several different versions that you can change between. The theory is also presented in the theory document mentioned above. Note that states and other variables change with the modifications (as expected). The different versions I have are:","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"Original (Under construction)\nGonzalez (Validated)","category":"page"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"1) @article{Leishman1989,\n\tAuthor = {J. G. Leishman and T. S. Beddoes},\n\tJournal = {Forum of the American Helicopter Society},\n\tTitle = {A Semi-Emprical Model for Dynamic Stall},\n\tVolume = {42},\n\tYear = {1989}}\n\n2) @article{Hansen2004,\n\tAuthor = {Morten Hartvig Hansen and Mac Gaunaa and Helge Aa. Madsen},\n\tJournal = {Riso National Laboratory},\n\tTitle = {A Beddoes-Leishman type dynamic stall model in state-space and indicial formulations},\n\tYear = {2004}}\n\n3) @techreport{Damiani2019,\n\tAuthor = {Rick Damiani and Greg Hayman},\n\tInstitution = {NREL},\n\tTitle = {The Unsteady Aerodynamics Module for FAST 8},\n\tYear = {2019}}\n","category":"page"},{"location":"Oye_theory/#Øye-Theory","page":"Øye Theory","title":"Øye Theory","text":"","category":"section"},{"location":"Oye_theory/","page":"Øye Theory","title":"Øye Theory","text":"Øye's model is a linear interpolation of fully attached lift (inviscid), and fully detached lift based on a dynamic degree of attachment. The dynamic attachment degree is a simple first-order filter on the separation point on the suction side of an airfoil. This dynamic degree of attachment is the Øye model's only state, which makes it the simplest dynamic stall model to implement.","category":"page"},{"location":"Oye_theory/","page":"Øye Theory","title":"Øye Theory","text":"The state is:","category":"page"},{"location":"Oye_theory/","page":"Øye Theory","title":"Øye Theory","text":"Variable Name Comments\nf^d Dynamic Attachment Degree This differential equation is also utilized in the Riso model and Beddoes-Leishman model","category":"page"},{"location":"Oye_theory/#State-Rate-Equation","page":"Øye Theory","title":"State Rate Equation","text":"","category":"section"},{"location":"Oye_theory/","page":"Øye Theory","title":"Øye Theory","text":"\nbeginequation\ndotf^d = -tau (f^d- f(alpha))\nendequation\n\n\nAs stated equation 1 is the only state rate equation in this model f^d is the state tau is the time constant and f^s(alpha) is the position of the fluids separation point as a function of the angle of attack (also known as the static separation point)\n\nAdditionally it should be noted that variables with a dot above them such as dotf^d are derivatives with respect to time\n\nThe above equation can be evaluated using a prefered ODE solver Once the solution is discovered it can be implemented into the following equation to solve for the dynamic lift\n\n\nbeginequation\nC_L(t) = f^d(t)C_l^inv + (1-f^d(t))C_l^fs\nendequation\n\n\nThe indicial approach simply solves equation 1 by assuming that the inflow velocity and angle of attack do not vary within the time step and using an integrating factor\n\n\nbeginequation\nf^d_i+1 = f^s(alpha_i) + (f^d_i - f^s(alpha_i))hspace3pte^-fracdttau\nendequation\n\n\n\n Explanation of Variables\n Time Constant\n\nThe time constant is experimentally determined and provides the needed information for how long it takes to come to steady state \n\n\nbeginequation\ntau = fracVA c\nendequation\n\n\nwhere tau is the time constant V is the inflow velocity (ms) A is the airfoil time coefficient and c is the airfoil chord (m) A is assumed to be A=4\nFor myriad reasons different authors have decided to rearrange this equation to suit their circumstance Since we verified our code against Faber and Larsen we present here their formulations for the airfoil time coefficient\n\nFaber multiplies the airfoil time coefficient by two\n\n\nbeginequation\nA = fracT2\nendequation\n\n\nand suggests a value of T=8 This provides for the exact same value as Øye but note that he uses slightly different notation than what is presented here\n\nLarsen used a dimensionalized and non-dimensionalized frequencies\n\n\nbeginequation\nA = frac12omega\nendequation\n\n\nwhere \n\nbeginequation*\nhatomega = fracomega c2v\nendequation*\n\n\n\n Static Separation Point\nØye assumes a linear interpolation between the inviscid and static lifts that interpolation percent he deems as the static separation point\n\n\nbeginequation\nf^s(alpha) = fracC_l^st - C_l^fsC_l^inv - C_l^fs\nendequation\n\n\n\nThe static attatchment degree f is used to describe the separation point of the fluid The range of values for f is in between 0 and 1 where 1 would indicate fully attatched flow and 0 represents fully separated flow If f were to equal a value of 075 then the fluid would have a separation point that occurs 75 the length of the chord away from the leading edge \n\nFor f(alpha) C_l^st represents the  static lift coefficient C_l^fs is the lift for an airfoil that is under the condition of fully separated flow and C_l^inv is the lift for an airfoil in inviscid flow It should also be mentioned that all of these coefficient of lift values are functions of angle of attack that range from alpha_0 leq alpha leq alpha_sep where alpha_0 is the angle of attack that produces zero lift and alpha_sep is the angle of attack where full separation occurs following static stall\n\nBecause C_l^inv is the lift under inviscid flow it has a completely linear relationship with the angle of attack The slope for the line of C_l^inv is equal to the slope of C_l^st at alpha_0 (ie fracpartial C_l^stpartial alphabig_alpha_0) This initial slope is approximately equal to 2pi which allows C_l^inv to be represented by the equation\n\nC_l^inv approx 2pi(alpha - alpha_0)","category":"page"},{"location":"Oye_theory/","page":"Øye Theory","title":"Øye Theory","text":"Note that here we default to 2pi, but ultimately the slope is set by the user. ","category":"page"},{"location":"Oye_theory/","page":"Øye Theory","title":"Øye Theory","text":"When Hansen describes this method in his textbook, he uses the same approach he used in his dynamic stall model:","category":"page"},{"location":"Oye_theory/","page":"Øye Theory","title":"Øye Theory","text":"$","category":"page"},{"location":"Oye_theory/","page":"Øye Theory","title":"Øye Theory","text":"\\begin{equation} f^s{H}\\left(\\alpha\\right) = \\left(2\\sqrt{\\frac{Cl^{st}}{C_l^{inv}}}\\right)^2 \\end{equation} $","category":"page"},{"location":"Oye_theory/#Fully-Separated-Lift-Coefficient","page":"Øye Theory","title":"Fully Separated Lift Coefficient","text":"","category":"section"},{"location":"Oye_theory/","page":"Øye Theory","title":"Øye Theory","text":"As was the case with finding the separation point, there are multiple ways to find the fully separated coefficient of lift. In Øye's original paper, he uses quadratic interpolation between C^s_l(alpha_0) and C_l^s(alpha_sep), with a derivative constraint at alpha_0. Thus the fully separated lift can be found by:","category":"page"},{"location":"Oye_theory/","page":"Øye Theory","title":"Øye Theory","text":"$","category":"page"},{"location":"Oye_theory/","page":"Øye Theory","title":"Øye Theory","text":"\\begin{equation}  C_l^{fs}(\\alpha) = a\\alpha^2 + b\\alpha + c  \\end{equation} $","category":"page"},{"location":"Oye_theory/","page":"Øye Theory","title":"Øye Theory","text":"where: ","category":"page"},{"location":"Oye_theory/","page":"Øye Theory","title":"Øye Theory","text":"$","category":"page"},{"location":"Oye_theory/","page":"Øye Theory","title":"Øye Theory","text":"\\begin{aligned} a = & \\frac{\\frac{\\partial Cl}{\\partial \\alpha}\\big|{\\alpha0}(\\alpha0-\\alpha{sep}) + C{l{sep}}}{(\\alpha0-\\alpha{sep})^2} \\\nb = & \\frac{-\\alpha0^2\\frac{\\partial Cl}{\\partial \\alpha}\\big|{\\alpha0} -2\\alpha0C{l{sep}} + \\frac{\\partial Cl}{\\partial \\alpha}\\big|{\\alpha0}\\alphas^2}{(\\alpha0-\\alpha{sep})^2} \\\nc = & \\frac{\\alpha0(\\alpha0(C{l{sep}}+\\frac{\\partial Cl}{\\partial \\alpha}\\big|{\\alpha0}\\alphas)-\\frac{\\partial Cl}{\\partial \\alpha}\\big|{\\alpha0}\\alphas^2)}{(\\alpha0-\\alpha{sep})^2} \\end{aligned} $","category":"page"},{"location":"Oye_theory/","page":"Øye Theory","title":"Øye Theory","text":"Note that this approach is only valid between alpha_0 and alpha_sep. ","category":"page"},{"location":"Oye_theory/","page":"Øye Theory","title":"Øye Theory","text":"Since Hansen used a different approach to find the static separation point, he utilizes the linear interpolation between the inviscid and static lift coefficients to find the fully separated lift. ","category":"page"},{"location":"Oye_theory/","page":"Øye Theory","title":"Øye Theory","text":"$","category":"page"},{"location":"Oye_theory/","page":"Øye Theory","title":"Øye Theory","text":"\\begin{equation} Cl^{fs}(\\alpha) = \\frac{Cl^{st} - f^s C_l^{inv}}{1-f^s} \\end{equation} $","category":"page"},{"location":"Oye_theory/","page":"Øye Theory","title":"Øye Theory","text":"Larsen and Faber use Hermite interpolation on the fully separated lift. Since the fully separated lift is unknown, they assume that the fully separated lift is equal to the static lift at alpha_0 and alpha_sep and there derivatives are: ","category":"page"},{"location":"Oye_theory/","page":"Øye Theory","title":"Øye Theory","text":"$","category":"page"},{"location":"Oye_theory/","page":"Øye Theory","title":"Øye Theory","text":"\\frac{\\partial Cl^{fs}}{\\partial \\alpha}|{\\alpha0} = \\frac{1}{2}(\\frac{\\partial Cl^{st}}{\\partial \\alpha}|{\\alpha0}) $","category":"page"},{"location":"Oye_theory/","page":"Øye Theory","title":"Øye Theory","text":"$","category":"page"},{"location":"Oye_theory/","page":"Øye Theory","title":"Øye Theory","text":"\\frac{\\partial Cl^{fs}}{\\partial \\alpha}|{\\alpha{sep}} = \\frac{1}{12}(\\frac{\\partial Cl^{st}}{\\partial \\alpha}|{\\alpha0}) $","category":"page"},{"location":"Oye_theory/","page":"Øye Theory","title":"Øye Theory","text":"Using these derivatives, we find the Hermite interpolation to be:","category":"page"},{"location":"Oye_theory/","page":"Øye Theory","title":"Øye Theory","text":"$","category":"page"},{"location":"Oye_theory/","page":"Øye Theory","title":"Øye Theory","text":"\\begin{equation} Cl^{fs}(\\alpha) = t0\\left((\\alpha{sep}-\\alpha0)\\frac{1}{2}\\frac{\\partial Cl^{st}}{\\partial \\alpha}\\bigg|{\\alpha0}\\left(1 + t0 \\left( \\frac{7}{6}t1-1\\right) \\right)+C{l{sep}}^{st}t0(1-2t_1) \\right) \\end{equation} $","category":"page"},{"location":"Oye_theory/","page":"Øye Theory","title":"Øye Theory","text":"where: $ \\begin{aligned} t0 = \\frac{\\alpha - \\alpha0}{\\alpha{sep}-\\alpha0} && t1 = \\frac{\\alpha - \\alpha{sep}}{\\alpha{sep}-\\alpha0} \\end{aligned} $","category":"page"},{"location":"Oye_theory/","page":"Øye Theory","title":"Øye Theory","text":"As with Øye's original model, this model is only valid between alpha_0 and alpha_sep. For this approach it is traditionally assumed that alpha_sep=32^circ. Note that in our implementation of this function we assume that the fully separated lift converges to the static lift outside of this region.","category":"page"},{"location":"Oye_theory/","page":"Øye Theory","title":"Øye Theory","text":"Just as the separation point has an option of how to solve for it, DynamicStallModels.jl allows the user to toggle which method they want to use to find C_l^fs.","category":"page"},{"location":"riso_theory/#Risø-Theory","page":"Risø Theory","title":"Risø Theory","text":"","category":"section"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"The Risø model^2 is a simplified version of the Beddoes-Leishman model, designed specifically for wind turbines.","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"It has four states. The four states are:","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"Variable Name Comments\nx_1  Using Theodorsen theory, we can come up with two ODEs to describe the change in the wake.\nx_2  The first state and second state model these changes. One is for high frequency changes while the other is for low frequency changes.\nx_3 = C_L^p Delayed coefficient of lift due to pressure. Delayed unsteady attached lift coefficient. A simple time lag (first order lag) between the pressure field and the lift.\nx_4 = f Delayed seperation point? Unsteady seperation point. This should range (0,1).","category":"page"},{"location":"riso_theory/#State-Rate-Equations","page":"Risø Theory","title":"State Rate Equations","text":"","category":"section"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"beginaligned\ndotx_1 = - fracx_1T_uleft(b_1 + fraccdotU2U^2right) + fracb_1A_1 alpha_34T_u \ndotx_2 = - fracx_2T_uleft(b_2 + fraccdotU2U^2right) + fracb_2A_2 alpha_34T_u \ndotx_3 = - fracx_3T_p + frac1T_pleft(fracpartial C_lpartial alpha(alpha_E - alpha_0) + pi T_u dotalpha right) \ndotx_4 = - fracx_4T_f = frac1T_ff^stleft(alpha_fright)\nendaligned","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"where x_i are the states of the model, T_x are time constants, A_i and b_i are airfoil specific constants describing the response of the airfoil, U is the freestream velocity, alpha_34 is the angle of attack the three-quarter point, fracpartial C_lpartial alpha is the slope of the static lift curve in the linear region, alpha_E is the equivalent angle of attack, f^st is the seperation point function, and alpha_f is the delayed angle of attack (this is something that I made up to make the notation a little clearer. ). ","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"A couple of notes: first, T_u is calculated, whereas the other two time constants are specific for the airfoil (although several authors have said that they are pretty constant from airfoil to airfoil... but at the same time, those authors give different values for the time constant than the other authors... so it seems pretty arbitrary). Second, variables with a dot above it (dotU for instance) indicate the derivative with respect to time. Third, recognize that U and alpha are both functions of time. Fourth, I just use the angle of attack for alpha_34... which appears to work, but Hansen's paper specifically seperates from the geometric angle of attack.","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"Now I'm going to dive into a bunch of the functions. ","category":"page"},{"location":"riso_theory/#First-Time-Constant","page":"Risø Theory","title":"First Time Constant","text":"","category":"section"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"T_u = fracc2U","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"where c is the chord, and U is the freestream velocity. Since U is a function of time, then this time constant isn't really constant...","category":"page"},{"location":"riso_theory/#Lift-Curve-Slope","page":"Risø Theory","title":"Lift Curve Slope","text":"","category":"section"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"Hansen gives an equation for fracpartial C_lpartial alpha, which makes it so that f^st never goes over 1.... which is just a max equation... but I feel like it is a lame excuse and it is more accurate if you use a value that matches the majority of the linear region. I feel like there should be a better way to define f^st so it never goes over 1, and plays nicely with optimization. At the same time he says: \"However, in cases where lift curves are provided directly from measurements, or CFD computations, it can be necessary to use linear regression to determine a linear lift curve in a range of lower angles of attack with fully attached flow.\" DG has said several times that it is fairly common to choose constants that recreate the static lift curve. ","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"fracpartial C_lpartial alpha = textmaxleft(fracC_l^st(alpha)(alpha - alpha_0)right)","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"where C_l^st is the lift from the static lift curve, and alpha_0 is the zero lift angle of attack. You'll frequently see fracpartial C_lpartial alphaleft(alpha - alpha_0right), which is just the inviscid lift. Note that in his paper, Hansen denotes the linear lift curve slope as C_Lalpha. ","category":"page"},{"location":"riso_theory/#Equivalent-Angle-of-Attack","page":"Risø Theory","title":"Equivalent Angle of Attack","text":"","category":"section"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"alpha_E = alpha_34(1 - A_1 - A_2) + x_1 + x_2","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"It's an equivalent angle of attack. Basically from what I understand is it is a weighting of what we expect the angle of attack to be from the geometric angle of attack and what the wake currently looks like.","category":"page"},{"location":"riso_theory/#Seperation-Point-Function","page":"Risø Theory","title":"Seperation Point Function","text":"","category":"section"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"Here is a function that gives me a little bit of problem:","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"f^st(alpha) = left(2 sqrtfracC_l^stC_l^i -1right)^2","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"where C_l^i is the inviscid lift coefficient. The inviscid lift coefficent, as previously mentioned, is simply: C_l^i(alpha) = fracpartial C_lpartial alpha (alpha - alpha_0). However, the value of this should always be on the range (0,1). It should be equal to 1 when the flow is fully attached (in the linear region), and 0 when the angle of attack is outside the angles of full seperation. Hansen defines the angles of full seperation as when the static lift is one-fourth the value of the inviscid lift:","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"C_l^st(alpha^pm fs) = leftfracpartial C_lpartial alphafrac(alpha^pm fs - alpha_0)4right","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"What I currently have implemented for the seperation pooint function is: ","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"f^st(alpha)=begincases\n          0 quad textif   alphaalpha^-fs  alphaalpha^+fs \n          1 quad textif   f^st  1    f^st = textNaN \n          left(2 sqrtfracC_l^stC_l^i -1right)^2 quad  textelse\n     endcases","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"Which isn't my favorite. But it works. ","category":"page"},{"location":"riso_theory/#Other-Time-Constants","page":"Risø Theory","title":"Other Time Constants","text":"","category":"section"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"T_f","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"describes the time lag in the boundary layer. ","category":"page"},{"location":"riso_theory/#Equations-for-the-Coefficients","page":"Risø Theory","title":"Equations for the Coefficients","text":"","category":"section"},{"location":"gettingstarted/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"The dynamic stall models are implemented in three ways: as a functional, an iterative, and in an indicial form. ","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Functional implementations create a struct that returns the state rates. This allows for easy solution using DifferentialEquations.jl. These functional implementations are designed to be passed a single set of parameters, p. Out of this set of parameters, several are functions, such as the freestream velocity. ","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Iterative implementations create a struct that returns the state rates as well, however they are not as easily solved by DifferentialEquations.jl. The input parameters are now all constant values, including the freestream velocity and angle of attack. This implementation is designed to be solved iteratively, meaning that for a given set of parameters, the states are updated for a single time step. The purpose of this type of implementation is for interfacing with other packages, specifically Rotors.jl. In the future, a function will be introduced that converts functions that describe environmental inputs into parameters, and then iterates through the solution of the model. ","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"The final implementation is an indicial formulation. Rather than providing a state space model to be solve, the model takes the environmental inputs and time step and calculates the states at the next time step. Several of the dynamic stall models included in this pakage were first developed in indicial form. ","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"We'll get started by using a functional implementation of the Risø model. Because we are using a functional implementation, we willl need our flow conditions as functions of time. We'll simulate a flat plate pitching in steady inflow. We'll look at a freestream velocity of 1 m/s, while the airfoil pitches plus or minus 1 degree (amplitude of 2) about 5 degrees. ","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"k = 0.2 #reduced frequency\nu = 1.0 #freestream velocity (m/s) \nc = 1.0 #Chord (m)\namplitude = 2\nshift = 5\n\nomega = k*2*u/c #Rate of oscillation\n\n### Prepare inputs\nU(t) = u #Freestream velocity as a function of time\nUdot(t) = 0.0 #Derivative of freestream velocity as a function of time\nalpha(t) = (amplitude*sin(omega*t) + shift)*(pi/180) #Angle of attack as a function of time (radians)\nalphadot(t) = (amplitude*omega*cos(omega*t)*(pi/180)) #Pitching rate as a function of time (radians)","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"At this point, we would normally read in an airfoil polar, however, since we are simulating a flat plate, we will use the inviscid solution for lift for a flat plate. ","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"\naoa = -pi:0.01:pi #Angle of Attack, (radians)\nlift = 2*pi.*(aoa) #Coefficient of lift\ndrag = zero(aoa) #Coefficient of drag, left zero for this demonstration. \npolar = hcat(aoa, lift, drag)\n\nA = [0.165, 0.335] #From the Hansen 2004 paper, for flat plate\nb = [0.0455, 0.3000] # \"\" \"\"\n\nTp = 3.0 # \"\" \"\" \nTf = 6.0 # \"\" \"\" \nT = [Tp, Tf]","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Now at this point, we'll store that information in an airfoil struct. ","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"using DynamicStallModels\n\nairfoils = Array{Airfoil, 1}(undef, 1)\nairfoils[1] = airfoil(polar; A, b, T)","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"If we had more airfoils, we would simply add them to the airfoils array. ","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Now we'll create the Risø struct, which will be our ODE to solve. ","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"dsmodel = Riso(airfoils; detype=Functional())","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"And now we prepare to solve using DifferentialEquations.jl. Note the order of p below, this is the required order. If simulating more than one airfoil, the chord lengths would be concatonated. So p = vcat([U, Udot, alpha, alphadot], [c]).","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"using DifferentialEquations\nx0 = zeros(4) #Hansen 2004's suggest initial conditions.\nx0[3] = 1.0\n\np = [U, Udot, alpha, alphadot, c]\n\ntspan = (0.0, 80.0)\n\nprob = ODEProblem(dsmodel, x0, tspan, p)","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Now let's solve using DifferentialEquations. A function to parse the DifferentialEquations solution and calculate the coefficients of lift and drag has been provided. ","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"sol = solve(prob, dtmax=0.1)\n\nCl, Cd, t =  parsesolution(dsmodel, sol, p)","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Also if the user has a specific set of states they would like to analyze, they can extract the states on their own and use the provided functions to calculate the coefficients. ","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"### Unpack\nx = Array(sol)'\nt = sol.t\n\nnt = length(t)\n\nclvec = zeros(nt, dsmodel.n)\ncdvec = zeros(nt, dsmodel.n)\n### run through the time steps and calculate the dynamic lift and drag (based on the states)\nfor i = 1:nt\n    ti = t[i]\n    for j = 1:dsmodel.n\n        clvec[i,j], cdvec[i,j] = riso_coefficients(x[i,:], U(ti), alpha(ti), alphadot(ti), cvec[j], dsmodel.airfoils[j])\n    end\nend","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Here we use Plots.jl to visualize the lift and compare against the values given in Hansen's 2004 paper where the model was presented. Note that shown is Hansen's indicial solution, whereas here we solve the state space model, so minor differences exist. ","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"using Plots\nalphavec = alpha.(sol.t)\n\nexpdata = readdlm(\"./data/Hansen2004/figure8_flatplate/indicial.csv\", ',')\n\n\nclplt = plot(legend=:topleft, title=\"Cyclic Alpha\", yaxis=\"Cl\", xaxis=\"Alpha (deg)\")\nscatter!(expdata[:,1], expdata[:,2], lab=\"Hansen 2004\")\nplot!(alphavec.*(180/pi), Cl, lab=\"DSM - Riso\")\nplot!(alphavec.*(180/pi), linearlift.(alphavec), lab=\"Static\")\ndisplay(clplt)","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"apireference/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"As you will see in the Code Outline and getting started, most of the code in this package revolves around creating instances of model, which have been formatted to be solved. There are some convenience functions for creating these structs. There are also some functions for parsing solutions. another change. another change. ","category":"page"},{"location":"apireference/#Airfoils","page":"API Reference","title":"Airfoils","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"DynamicStallModels.Airfoil","category":"page"},{"location":"apireference/#DynamicStallModels.Airfoil","page":"API Reference","title":"DynamicStallModels.Airfoil","text":"Airfoil(polar::Array{TF, 2}, cl::Tfit, cd::Tfit, cm::Tfit, dcldalpha::TF, alpha0::TF, alphasep::Array{TF, 1}, A::Array{TF, 1}, b::Array{TF, 1}, T::Array{TF, 1})\n\nA struct to hold all of the airfoil polars, fits, and dynamic coefficients. \n\nInputs\n\npolar - A matrix of floats describing the airfoil polar. This includes the angle of attack (radians), and coefficients of lift, drag, and moment. \ncl - A fit of the coefficient of lift as a function of the angle of attack (radians). \ncd - A fit of the coefficient of drag as a function of the angle of attack (radians). \ncm - A fit of the coefficient of moment as a function of the angle of attack (radians). \ndcldalpha - The lift curve slope in the linear region (1/radians). Typically near 2 pi. \nalpha0 - The zero lift angle of attack (radians). \nalphasep - A vector of floats holding the angles of attack at which flow fully seperates from the airfoil. In order from least to greatest. \nA - A vector of floats holding the A dynamic constants for the airfoil. \nb - A vector of floats holding the b dynamic constants for the airfoil. \nT - A vector of floats holding the time constants for the airfoil. \nS - A vector of floats holding the S constants are best fit constants for the separation point curve. \ns - A fit of the the separation point curve. \n\n\n\n\n\n","category":"type"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"simpleairfoil","category":"page"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"airfoil","category":"page"},{"location":"apireference/#Beddoes-Leishman","page":"API Reference","title":"Beddoes-Leishman","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"BeddoesLeishman","category":"page"},{"location":"apireference/#DynamicStallModels.BeddoesLeishman","page":"API Reference","title":"DynamicStallModels.BeddoesLeishman","text":"BeddoesLeishman(detype::DEType, n::Int, airfoils::Array{Airfoil, 1}, version::Int)\n\nThe Beddoes-Leishman model struct. It stores airfoil data for every section to be simulated. It can be used as a method to return updated states or state rates depending on it's DEType. \n\nInputs\n\ndetype - The type of model it is, Continuous(), Discrete(), or Discrete().\nn - The number of sections to be simulated. \nairfoils - A vector of Airfoil structs, one corresponding to each section to be simulated. \nversion - Which version of the Discrete implementation. 1) original. 2) AeroDyn original. 3) AeroDyn Gonzalez. 4) AeroDyn Minema\n\n\n\n\n\n","category":"type"},{"location":"apireference/#Larsen","page":"API Reference","title":"Larsen","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"Larsen","category":"page"},{"location":"apireference/#Onera","page":"API Reference","title":"Onera","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"Onera","category":"page"},{"location":"apireference/#Oye","page":"API Reference","title":"Oye","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"Oye","category":"page"},{"location":"apireference/#DynamicStallModels.Oye","page":"API Reference","title":"DynamicStallModels.Oye","text":"Oye(detype::DEType, n::Int, airfoils::Array{Airfoil, 1})\n\nThe Øye model struct. It stores airfoil data for every section to be simulated. It can be used as a method to return updated states or state rates depending on it's DEType. \n\nInputs\n\ndetype - The type of model it is, Continuous() or Discrete().\ncflag::Int - A flag to apply the separation delay to the coefficient of 1) lift, 2) normal force. \nversion::Int - A flag to say whether to use 1) Hansen 2008, or 2) Larsen's Hermite interpolation from Faber's 2018's implementation of the model.\nA::Float - Dynamic stall coefficient. \n\n\n\n\n\n","category":"type"},{"location":"apireference/#Risø","page":"API Reference","title":"Risø","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"Riso","category":"page"},{"location":"apireference/#DynamicStallModels.Riso","page":"API Reference","title":"DynamicStallModels.Riso","text":"Riso(detype::DEType, n::Int, airfoils::Array{Airfoil, 1})\n\nThe Risø model struct. It stores airfoil data for every section to be simulated. It can be used as a method to return updated states or state rates depending on it's DEType. \n\nInputs\n\ndetype - The type of model it is, Continuous() or Discrete().\nn - The number of sections to be simulated. \nairfoils - A vector of Airfoil structs, one corresponding to each section to be simulated. \n\n\n\n\n\n","category":"type"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"riso","category":"page"},{"location":"beddoesleishman_example/#Beddoes-Leishman","page":"Beddoes-Leishman","title":"Beddoes-Leishman","text":"","category":"section"},{"location":"beddoesleishman_example/#Original-and-State-Space-Implementations","page":"Beddoes-Leishman","title":"Original and State Space Implementations","text":"","category":"section"},{"location":"beddoesleishman_example/","page":"Beddoes-Leishman","title":"Beddoes-Leishman","text":"These implementations are still under construction. ","category":"page"},{"location":"beddoesleishman_example/#AeroDyn-Implementations","page":"Beddoes-Leishman","title":"AeroDyn Implementations","text":"","category":"section"},{"location":"beddoesleishman_example/","page":"Beddoes-Leishman","title":"Beddoes-Leishman","text":"This model is also indicial form, so it will behave similarly to all the other indicial implementations. There are some key differences in this implementation from the original implementation, and they are noted in the theory tab. ","category":"page"},{"location":"beddoesleishman_example/","page":"Beddoes-Leishman","title":"Beddoes-Leishman","text":"Since this same model is implemented in AeroDyn, we use OpenFASTTools.jl and some AeroDyn inputs and outputs to compare against. First we'll read in information about the airfoil. ","category":"page"},{"location":"beddoesleishman_example/","page":"Beddoes-Leishman","title":"Beddoes-Leishman","text":"using DynamicStallModels, OpenFASTTools\nof = OpenFASTTools\ndu21_a17 = of.read_airfoilinput(\"../../../data/DU21_A17.dat\")\naf = of.make_dsairfoil(du21_a17)","category":"page"},{"location":"beddoesleishman_example/","page":"Beddoes-Leishman","title":"Beddoes-Leishman","text":"Now we create a vector of airfoils. Here we will only test a single airfoil, so we will store that lone airfoil in a vector. ","category":"page"},{"location":"beddoesleishman_example/","page":"Beddoes-Leishman","title":"Beddoes-Leishman","text":"airfoils = Array{Airfoil, 1}(undef, 1)\nairfoils[1] = af","category":"page"},{"location":"beddoesleishman_example/","page":"Beddoes-Leishman","title":"Beddoes-Leishman","text":"Next we create an instance of the model that we want to simulate. We'll use Beddoes-Leishman, with Gonzalez's modifications (the third model). ","category":"page"},{"location":"beddoesleishman_example/","page":"Beddoes-Leishman","title":"Beddoes-Leishman","text":"dsmodel = BeddoesLeishman(Indicial(), 1, airfoils, 3)","category":"page"},{"location":"beddoesleishman_example/","page":"Beddoes-Leishman","title":"Beddoes-Leishman","text":"Now we need some inflow information. We'll use information that is passed to the unsteady module in OpenFAST. We need the inflow velocity and relative angle of attack for every time step of our simulation. ","category":"page"},{"location":"beddoesleishman_example/","page":"Beddoes-Leishman","title":"Beddoes-Leishman","text":"using DelimitedFiles\nfullout = readdlm(\"../../../data/aerodynout_fordynamicstall.csv\", ',')\nnames = fullout[1,:]\nnames[1] = \"Time\"\ndata = Float64.(fullout[3:end,:])\n\nouts = Dict(names[i] => data[:,i] for i in 1:length(names)) \n\ntvec = outs[\"Time\"]\nnt = length(tvec)\n\nUvec = [sqrt(outs[\"AB1N011Vx\"][i]^2 + outs[\"AB1N011Vy\"][i]^2) for i in 1:nt] #m/s\naoavec = outs[\"AB1N011Alpha\"].*(pi/180)","category":"page"},{"location":"beddoesleishman_example/","page":"Beddoes-Leishman","title":"Beddoes-Leishman","text":"Before we can solve the time series, we need the chord length. Here we'll assume the length is 1m. Then we can solve. ","category":"page"},{"location":"beddoesleishman_example/","page":"Beddoes-Leishman","title":"Beddoes-Leishman","text":"c = 1.0\n\nstates, loads = solve_indicial(dsmodel, [c], tvec, Uvec, aoavec)","category":"page"},{"location":"beddoesleishman_example/","page":"Beddoes-Leishman","title":"Beddoes-Leishman","text":"Now we can visualize the outputs using Plots. ","category":"page"},{"location":"beddoesleishman_example/","page":"Beddoes-Leishman","title":"Beddoes-Leishman","text":"Cn = loads[:,1] #The columns of loads are Cn, Cc, Cl, Cd, Cm\n\nusing Plots, LaTeXStrings\n\ncnplt = plot(xaxis=\"Time (s)\", yaxis=L\"C_n\")\nplot!(tvec, Cn, lab=\"BL_AD\")\nplot!(tvec, outs[\"AB1N011Cn\"], linestyle=:dash, lab=\"OpenFAST\")\ndisplay(cnplt)","category":"page"},{"location":"riso_example/#Risø-Model","page":"Risø Model","title":"Risø Model","text":"","category":"section"},{"location":"codeoutline/#Code-Outline","page":"Code Outline","title":"Code Outline","text":"","category":"section"},{"location":"codeoutline/","page":"Code Outline","title":"Code Outline","text":"Here I will outline the code and how it all fits together. In case you wanted to add something to this package. I expect that you've read the other documentation, as it provides important information that is required to work on this package. ","category":"page"},{"location":"#DynamicStallModels.jl","page":"Introduction","title":"DynamicStallModels.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This package is a collection of different dynamic stall models. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Dynamic stall models included in this package: ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Beddoes-Leishman\nState Space \nIndicial\nAeroDyn implementation (original and Gonzalez variants)\nRisø (Hansen 2004)\nState Space\nIndicial\nLarsen\nOnera\nOye","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"To get started, add the package. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"pkg> add https://github.com/byuflowlab/DynamicStallModels.jl.git","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Then checkout the Getting Started page. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"warning: Warning - Lack of Validation\nAn important thing to note is the lack of validation. Except for the AeroDyn implementation, the Beddoes-Leishman implementations are very far from validated and likely still have bugs.  The Risø models perform much better. For attached conditions, the models perform as expected compare excellently to published data (see the validation section of theory (that has yet to be created)). In stall conditions, when actual stall occurs, the models do not perform as expected. We were unable to find the operating conditions that Hansen did his simulations at, and so we assumed them. We were able to get a decent match by optimizing the dynamic coefficients, but they were much different than the ones Hansen provided.  The Onera model has been validated (The validation needs to be added). ","category":"page"},{"location":"#References","page":"Introduction","title":"References","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Please check our References page to see the original authors of content presented herein. ","category":"page"},{"location":"Oye_example/#Øye","page":"Øye","title":"Øye","text":"","category":"section"},{"location":"Oye_example/","page":"Øye","title":"Øye","text":"","category":"page"},{"location":"Oye_example/#Functional-Solve-Example","page":"Øye","title":"Functional Solve Example","text":"","category":"section"},{"location":"Oye_example/","page":"Øye","title":"Øye","text":"This version of the Øye method uses the functional solve. The functional solve uses an ODE solver like DifferentialEquations.jl to automaticall solve the state rate equations.","category":"page"},{"location":"Oye_example/","page":"Øye","title":"Øye","text":"To begin, we prepare for the functional solve. In this example, a NACA 0015 polar from Faber's paper is read in using the package DelimitedFiles. Additionally, the model that we will be using for the solve is set up in this block. The Øye method is chosen for the dynamic stall model; the functional solve is picked; the number 1 indicates that the coefficient of lift is being evaluated; the number 2 shows that the Faber/Larsen use of Hermite interpolation for the fully separated lift is used; and the 4.0 value is the constant used in the time scale parameter.","category":"page"},{"location":"Oye_example/","page":"Øye","title":"Øye","text":"using DynamicStallModels, DelimitedFiles\ndsm = DynamicStallModels\npolar_0015 = readdlm(\"NACA_0015_Faber.csv\" , ',')\ndsmodel = Oye(Functional(), 1, 2, 4.0)","category":"page"},{"location":"Oye_example/","page":"Øye","title":"Øye","text":"The chord length, mach number, and inflow velocity are then prepared.","category":"page"},{"location":"Oye_example/","page":"Øye","title":"Øye","text":"c = 0.55\nM = 0.11\na = 343.0\nVrel = M*a ","category":"page"},{"location":"Oye_example/","page":"Øye","title":"Øye","text":"The airfoil function is now created. In order to do this, the polar, the model, and the chord length are passed into the make_airfoil function. The sfun value at the end indicates that we are using the Larsen separation point function for this solve.","category":"page"},{"location":"Oye_example/","page":"Øye","title":"Øye","text":"An array is then generated to hold the information of all the airfoils that we want to evaluate. In this case, only one airfoil is being tested, so this array is of length 1 and filled with our single airfoil function.","category":"page"},{"location":"Oye_example/","page":"Øye","title":"Øye","text":"af = dsm.make_airfoil(polar_0015, dsmodel, c; sfun=dsm.LSP())\nairfoils = Array{Airfoil, 1}(undef, 1)\nairfoils[1] = af","category":"page"},{"location":"Oye_example/","page":"Øye","title":"Øye","text":"A touple containing the span of time that we want to evaluate over is now generated.","category":"page"},{"location":"Oye_example/","page":"Øye","title":"Øye","text":"tspan = (0, 2.0)","category":"page"},{"location":"Oye_example/","page":"Øye","title":"Øye","text":"Two functions with respect to time are created, as well. Uvector gives the inflow velocity and alpha gives the angle of attack of the airfoil.","category":"page"},{"location":"Oye_example/","page":"Øye","title":"Øye","text":"function Uvector(t)\n    return Vrel\nend\nfunction alpha(t)\n    c = 0.55\n    M = 0.11\n    a = 343.0\n    shift = 10.0\n    amp = 10.0\n    k = 0.051\n\n    v = M*a\n    omega = k*2*v/c\n\n    alf = shift + amp*sin(omega*t)\n    return alf*(pi/180)\nend","category":"page"},{"location":"Oye_example/","page":"Øye","title":"Øye","text":"The parameters and initial condition for this solve can now be generated. The order for the parameter vector is imperative. The order for the inputted values should be the inflow velocity, the rate of change of the inflow velocity, the angle of attack, and the rate of change of the angle of attack. If multiple airfoils are being evaluated, then this pattern will just continue onwards through the vector's indices. Since this example only solves a single airfoil, only four inputs are required into the parameters vector. Additionally, the rate of change of the angle of attack and inflow velocity are not required for the Øye method, so they are just inputted in as 0.0.","category":"page"},{"location":"Oye_example/","page":"Øye","title":"Øye","text":"Additionally, any initial condition between 0.0 and 1.0 is good for the Øye method. The solution will converge if a value is picked in this range. Since we are only evaluating a single airfoil, there is only one initial condition required for this method.","category":"page"},{"location":"Oye_example/","page":"Øye","title":"Øye","text":"parameters = [Uvector, 0.0, alpha, 0.0]\nx_initial = [0.8]","category":"page"},{"location":"Oye_example/","page":"Øye","title":"Øye","text":"The ODE problem is now created using the ODEProblem function.","category":"page"},{"location":"Oye_example/","page":"Øye","title":"Øye","text":"prob = ODEProblem(airfoils, x_initial, tspan, parameters)","category":"page"},{"location":"Oye_example/","page":"Øye","title":"Øye","text":"The problem from the previous block of code can now be passed into the solve function of DifferentialEquations.jl. The keyword reltol adds more control to the step size in the solve and allows for more precise solutions.","category":"page"},{"location":"Oye_example/","page":"Øye","title":"Øye","text":"sol = DifferentialEquations.solve(prob, reltol=1e-8)","category":"page"},{"location":"Oye_example/","page":"Øye","title":"Øye","text":"With the solution found, the parsesolution function can be used to find the dynamic lift or normal force coefficients. This function outputs a matrix that contains alternating rows of the angle of attacks and their corresponding coefficient values for each airfoil.","category":"page"},{"location":"Oye_example/","page":"Øye","title":"Øye","text":"answer = parsesolution(dsmodel, af, sol, parameters)","category":"page"},{"location":"Oye_example/","page":"Øye","title":"Øye","text":"Using Plots allows us to view the results of our functional solve.","category":"page"},{"location":"Oye_example/","page":"Øye","title":"Øye","text":"using Plots, LaTeXStrings\ncyclecnplt = plot(xaxis=\"Angle of Attack (deg)\", yaxis=L\"C_L\", leg=:bottomright)\nplot(answer[1,:].*180/pi, answer[2,:])","category":"page"},{"location":"Oye_example/","page":"Øye","title":"Øye","text":"","category":"page"},{"location":"Oye_example/#Indicial-Solve-Example","page":"Øye","title":"Indicial Solve Example","text":"","category":"section"},{"location":"Oye_example/","page":"Øye","title":"Øye","text":"","category":"page"},{"location":"Oye_example/","page":"Øye","title":"Øye","text":"This version of the Øye method utilizes the indicial solve. An indicial solve analytically solves the state rate equation and solves for new state values with a time step. ","category":"page"},{"location":"Oye_example/","page":"Øye","title":"Øye","text":"To begin, we prepare for our indicial solve. In this example, a NACA 0015 polar from Faber's paper is read in using the package DelimitedFiles. Additionally, the model that we will be using for the solve is set up in this block. The Øye method is chosen for the dynamic stall model; an indicial solve is picked; the number 1 indicates that the coefficient of lift is being evaluated; the number 2 shows that the Faber/Larsen use of Hermite interpolation for the fully separated lift is used; and the 4.0 value is the constant used in the time scale parameter.","category":"page"},{"location":"Oye_example/","page":"Øye","title":"Øye","text":"using DynamicStallModels, DelimitedFiles\ndsm = DynamicStallModels\npolar_0015 = readdlm(\"NACA_0015_Faber.csv\" , ',')\ndsmodel = Oye(Indicial(), 1, 2, 4.0)","category":"page"},{"location":"Oye_example/","page":"Øye","title":"Øye","text":"Next, the chord length, mach number, and velocity are generated.","category":"page"},{"location":"Oye_example/","page":"Øye","title":"Øye","text":"c = 0.55\nM = 0.11\na = 343.0\nVrel = M*a ","category":"page"},{"location":"Oye_example/","page":"Øye","title":"Øye","text":"The airfoil function is now created. In order to do this, the polar, the model, and the chord length are passed into the make_airfoil function. The sfun value at the end indicates that we are using the Larsen separation point function for this solve. ","category":"page"},{"location":"Oye_example/","page":"Øye","title":"Øye","text":"An array is then generated to hold the information of all the airfoils that we want to evaluate. In this case, only one airfoil is being tested, so this array is of length 1 and filled with our single airfoil function.","category":"page"},{"location":"Oye_example/","page":"Øye","title":"Øye","text":"af = dsm.make_airfoil(polar_0015, dsmodel, c; sfun=dsm.LSP())\nairfoils = Array{Airfoil, 1}(undef, 1)\nairfoils[1] = af","category":"page"},{"location":"Oye_example/","page":"Øye","title":"Øye","text":"Here, the range of time values is set up, and the angle of attack function with respect to time is created.","category":"page"},{"location":"Oye_example/","page":"Øye","title":"Øye","text":"tvec = range(0, 1.0, 1000)\nfunction alpha(t)\n    c = 0.55\n    M = 0.11\n    a = 343.0\n    shift = 10.0\n    amp = 10.0\n    k = 0.051\n\n    v = M*a\n    omega = k*2*v/c\n\n    alf = shift + amp*sin(omega*t)\n    return alf*(pi/180)\nend","category":"page"},{"location":"Oye_example/","page":"Øye","title":"Øye","text":"With the previous values prepared, a vector of the angle of attack at each time value is created. Additionally, the inflow velocity vector is made. Since the inflow velocity for this problem is constant, every value in this vector will be the same.","category":"page"},{"location":"Oye_example/","page":"Øye","title":"Øye","text":"alphavec = alpha.(tvec)\nUvec = Vrel.*ones(length(tvec))","category":"page"},{"location":"Oye_example/","page":"Øye","title":"Øye","text":"The state values and loads can be found using the solve_indicial function.","category":"page"},{"location":"Oye_example/","page":"Øye","title":"Øye","text":"states, loads = solve_indicial(airfoils, tvec, Uvec, alphavec)","category":"page"},{"location":"Oye_example/","page":"Øye","title":"Øye","text":"This block of code changes the load values to either be with respect to lift or normal force coefficients.","category":"page"},{"location":"Oye_example/","page":"Øye","title":"Øye","text":"cn = loads[:,1]\nif dsmodel.cflag == 2\n    cn_static = af.cn.(alphavec)\nelse\n    cn_static = af.cl.(alphavec)\nend","category":"page"},{"location":"Oye_example/","page":"Øye","title":"Øye","text":"Now, the dynamic loads or state values can be viewed using Plots","category":"page"},{"location":"Oye_example/","page":"Øye","title":"Øye","text":"using Plots, LaTeXStrings\nstateplt = plot(tvec, states[:,1], leg=false, xaxis=\"time (s)\", yaxis=\"f\")\ncyclecnplt = plot(xaxis=\"Angle of Attack (deg)\", yaxis=L\"C_L\", leg=:bottomright)\nplot!(alphavec.*(180/pi), cn, lab=\"DSM\")\nplot!(alphavec.*(180/pi), cn_static, lab=\"Static\")\ndisplay(cyclecnplt) ","category":"page"}]
}
