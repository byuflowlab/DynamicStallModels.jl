var documenterSearchIndex = {"docs":
[{"location":"gettingstarted/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"The dynamic stall models are implemented in three ways: as a functional, an iterative, and in an indicial form. ","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Functional implementations create a struct that returns the state rates. This allows for easy solution using DifferentialEquations.jl. These functional implementations are designed to be passed a single set of parameters, p. Out of this set of parameters, several are functions, such as the freestream velocity. ","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Iterative implementations create a struct that returns the state rates as well, however they are not as easily solved by DifferentialEquations.jl. The input parameters are now all constant values, including the freestream velocity and angle of attack. This implementation is designed to be solved iteratively, meaning that for a given set of parameters, the states are updated for a single time step. The purpose of this type of implementation is for interfacing with other packages, specifically Rotors.jl. In the future, a function will be introduced that converts functions that describe environmental inputs into parameters, and then iterates through the solution of the model. ","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"The final implementation is an indicial formulation. Rather than providing a state space model to be solve, the model takes the environmental inputs and time step and calculates the states at the next time step. Several of the dynamic stall models included in this pakage were first developed in indicial form. ","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"We'll get started by using a functional implementation of the Risø model. Because we are using a functional implementation, we willl need our flow conditions as functions of time. We'll simulate a flat plate pitching in steady inflow. We'll look at a freestream velocity of 1 m/s, while the airfoil pitches plus or minus 1 degree (amplitude of 2) about 5 degrees. ","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"k = 0.2 #reduced frequency\nu = 1.0 #freestream velocity (m/s) \nc = 1.0 #Chord (m)\namplitude = 2\nshift = 5\n\nomega = k*2*u/c #Rate of oscillation\n\n### Prepare inputs\nU(t) = u #Freestream velocity as a function of time\nUdot(t) = 0.0 #Derivative of freestream velocity as a function of time\nalpha(t) = (amplitude*sin(omega*t) + shift)*(pi/180) #Angle of attack as a function of time (radians)\nalphadot(t) = (amplitude*omega*cos(omega*t)*(pi/180)) #Pitching rate as a function of time (radians)","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"At this point, we would normally read in an airfoil polar, however, since we are simulating a flat plate, we will use the inviscid solution for lift for a flat plate. ","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"\naoa = -pi:0.01:pi #Angle of Attack, (radians)\nlift = 2*pi.*(aoa) #Coefficient of lift\ndrag = zero(aoa) #Coefficient of drag, left zero for this demonstration. \npolar = hcat(aoa, lift, drag)\n\nA = [0.165, 0.335] #From the Hansen 2004 paper, for flat plate\nb = [0.0455, 0.3000] # \"\" \"\"\n\nTp = 3.0 # \"\" \"\" \nTf = 6.0 # \"\" \"\" \nT = [Tp, Tf]","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Now at this point, we'll store that information in an airfoil struct. ","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"using DynamicStallModels\n\nairfoils = [airfoil(polar; A, b, T)]","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"If we had more airfoils, we would simply add them to the airfoils array. ","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Now we'll create the Risø struct, which will be our ODE to solve. ","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"dsmodel = Riso(airfoils; detype=Functional())","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"And now we prepare to solve using DifferentialEquations.jl. Note the order of p below, this is the required order. If simulating more than one airfoil, the chord lengths would be concatonated. So p = vcat([U, Udot, alpha, alphadot], [c]).","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"using DifferentialEquations\nx0 = zeros(4) #Hansen 2004's suggest initial conditions.\nx0[3] = 1.0\n\np = [U, Udot, alpha, alphadot, c]\n\ntspan = (0.0, 80.0)\n\nprob = ODEProblem(dsmodel, x0, tspan, p)","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Now let's solve using DifferentialEquations. A function to parse the DifferentialEquations solution and calculate the coefficients of lift and drag has been provided. ","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"sol = solve(prob, dtmax=0.1)\n\nCl, Cd, t =  parsesolution(dsmodel, sol, p)","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Also if the user has a specific set of states they would like to analyze, they can extract the states on their own and use the provided functions to calculate the coefficients. ","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"### Unpack\nx = Array(sol)'\nt = sol.t\n\nnt = length(t)\n\nclvec = zeros(nt, dsmodel.n)\ncdvec = zeros(nt, dsmodel.n)\n### run through the time steps and calculate the dynamic lift and drag (based on the states)\nfor i = 1:nt\n    ti = t[i]\n    for j = 1:dsmodel.n\n        clvec[i,j], cdvec[i,j] = riso_coefficients(x[i,:], U(ti), alpha(ti), alphadot(ti), cvec[j], dsmodel.airfoils[j])\n    end\nend","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Here we use Plots.jl to visualize the lift and compare against the values given in Hansen's 2004 paper where the model was presented. Note that shown is Hansen's indicial solution, whereas here we solve the state space model, so minor differences exist. ","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"using Plots\nalphavec = alpha.(sol.t)\n\nexpdata = readdlm(\"./data/Hansen2004/figure8_flatplate/indicial.csv\", ',')\n\n\nclplt = plot(legend=:topleft, title=\"Cyclic Alpha\", yaxis=\"Cl\", xaxis=\"Alpha (deg)\")\nscatter!(expdata[:,1], expdata[:,2], lab=\"Hansen 2004\")\nplot!(alphavec.*(180/pi), Cl, lab=\"DSM - Riso\")\nplot!(alphavec.*(180/pi), linearlift.(alphavec), lab=\"Static\")\ndisplay(clplt)","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"beddoesleishman_theory/#Beddoes-Leishman-Theory","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"","category":"section"},{"location":"beddoesleishman_theory/#State-Rate-Equations","page":"Beddoes-Leishman Theory","title":"State Rate Equations","text":"","category":"section"},{"location":"beddoesleishman_theory/#Equations","page":"Beddoes-Leishman Theory","title":"Equations","text":"","category":"section"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"reduced linear lift coefficient - high frequency (or low, don't know which) (EQ 13)","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"$","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"\\dot{c}1 + \\omega1 c1(t) = A1 \\dot{C}_{L0}(t) $","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"reduced linear lift coefficient - low frequency (EQ 13)","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"$","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"\\dot{c}2 + \\omega2 c2(t) = A2 \\dot{C}_{L0}(t) $","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"impulsive contributions diminishing in time due to wave propagation. (EQ A.2)","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"$","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"\\dot{c}3 + \\omega5 c3(t) = \\frac{4}{M}A3\\dot{\\alpha} $","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"''   ''   ''   ''   ''   ''   ''  (EQ A.2)","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"$","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"\\dot{c}4 + \\omega6 c4(t) = \\frac{1}{M}A4\\frac{c}{V}\\ddot{\\alpha} $","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"The retarded linear lift C_L0d(t)​​  is introduced as a delayed state variable of the linear lift C_L0d(t)​​​, which gives a one-to-one correspondence between the pressure coefficient and the dynamic lift at changing pitch rates (EQ A.3)","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"$","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"\\dot{C}'{L0,d}(t) = -\\omega7\\bigg(C'{L0,d}(t) - C{L0,d}(t)\\bigg) $","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"Which when you plug everything in, then you get a  different equation: (EQ A.5) $ \\dot{C}'{L0,d}(t) = \\omega7\\bigg(-c1(t) - c2(t) + c3(t) + c4(t) - C'{L0,d}(t) + C{L0}(\\alpha)\\bigg) $","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"dynamic attachment degree (EQ 16)","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"$","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"\\dot{f}d = - \\omega3 \\bigg(f_d(t)-f(\\alpha)\\bigg) $","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"Leading edge vortex contribution (EQ 22)","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"$","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"\\dot{C}{L,v}(t) + \\omega4 C{L,v}(t) =  \\begin{cases} \\Delta \\dot{C}L(t) \\quad \\textrm{for} \\quad \\tau < 1 \\hspace{3pt} \\textrm{and} \\hspace{3pt} \\dot{\\alpha}>0 \\\n0 \\hspace{38pt} \\textrm{otherwise} \\end{cases} $","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"Time Constant** (EQ 21)","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"$","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"\\dot{\\tau} =  \\begin{cases} \\frac{V}{3c} \\quad \\textrm{for} \\quad \\alpha>\\alpha_v,\\\n0 \\quad \\textrm{otherwise} \\end{cases} $","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"** This state variable was not included in the original formulation, however, they included a time constant tau that was the position of the leading edge vortex, and it moves with a speed of dottau​​, so I figured, I'd make it a state variable that was really simple. Let the solver manage that information. I don't think that I could write something to manage it better. ","category":"page"},{"location":"beddoesleishman_theory/#Indicial-Formulation-(Original)","page":"Beddoes-Leishman Theory","title":"Indicial Formulation (Original)","text":"","category":"section"},{"location":"beddoesleishman_theory/#Indicial-Formulation-(AeroDyn)sup3/sup","page":"Beddoes-Leishman Theory","title":"Indicial Formulation (AeroDyn)<sup>3</sup>","text":"","category":"section"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"AeroDyn has it's own implementation of the Beddoes-Leishman model, with several variations here and there. The method is presented here. Frequently the method is presented in a way that makes sense theoretically, here however, we will present the method in the order that the functions are calculated. ","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"==I need to list the states that this uses.==","category":"page"},{"location":"beddoesleishman_theory/#States","page":"Beddoes-Leishman Theory","title":"States","text":"","category":"section"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"AeroDyn lists a set of discrete states that are different from what a demarcated as the states from the original Beddoes-Leishman model. These states make sense when you consider simulation, as you need this information from step to step. ","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"Variable Name Comments\nalpha Angle of Attack  (AOA) \nalpha_lp Low-pass-filtered AOA \nalpha_f Delayed effective Angle of Incidence (AOI) \nq Pitch rate \nX_1  \nX_2  \nX_3  \nX_4  \nK_alpha Deficiency function for noncirulatory component of normal force based on angle of attack \nK_q Deficiency function for noncirulatory component of normal force based on pitching rate \nK_q Deficiency function for noncirulatory component of moment \nK_q Deficiency function for cirulatory component of moment \nD_p Deficiency function for cirulatory component of normal force \nD_f Deficiency function for the separation point \nD_f_c  \nC_n^pot  \nf  \nf_c  \nf  \nf_c  \ntau_v  \nC_n^v  \nC_v  \nD_alpha f  ","category":"page"},{"location":"beddoesleishman_theory/#Logical-Flags","page":"Beddoes-Leishman Theory","title":"Logical Flags","text":"","category":"section"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"if UAmod == 1\n    # Closest model to the original Leishman-Beddoes formulation\nelseif UAmod == 2\n    # Modifications to the original model and simplifications following Gonzalex (2014)\n        #= Equations\n        1.58 -> 1.60\n        1.56 -> 1.55b\n        1.53 -> 1.53b\n        1.49 -> 1.50\n        1.41 -> 1.45\n        1.38 -> 1.39\n        add 1.16 to Ccnalphaq(s,M) Eq(1.13)\n        =#\nelse #UAmod == 3\n    # Modifications to the original model and simplifications following Pierce (1996) and Minnema (1998)\n        #= Equations\n        1.56 -> 1.55\n        1.58 -> 1.59\n        1.41 -> 1.43-1.44\n        Modify 1.30 with 1.31\n        =#\nend\n\nif flookup # == true\n    # EQ 1.33 gets replaced by lookup values for f'n and f'c. Note that if UAmod == 2 or 3, the flag is automatically set to true. \nend","category":"page"},{"location":"beddoesleishman_theory/#Update-Discrete-States","page":"Beddoes-Leishman Theory","title":"Update Discrete States","text":"","category":"section"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"(1.11c) (Some time constant)\nT_I = fracca\n(1.5b) Nondimensional distance\nDelta s = frac2cU(t)Delta t\n1.7 - 1.8\n(1.7) Nondimensional pitch rate\nq = fracdotalphacU approx fracK_alpha ncc\nK_alpha n = frac alpha_n - alpha_n-1Delta t\n(1.8) Applying a low pass filter to K_alpha.\nalpha_lp_n = C_lpalpha_lp_n-1 + (1 - C_lp)alpha_n\n(low-pass-filtered alpha)\nq_n = frac(alpha_lp_n - alpha_lp_n-1)cU_n Delta t\nq_lp_n = C_lpq_lp_n-1 + (1 - C_lp)q_n\n(low-pass-filtered q)\nK_alpha lp_n = fracq_lp_nU_nDelta t\n(modified value of K_alpha)\nK_q_n = fracq_n - q_n-1Delta t\n(backward finite difference of q)\nK_qlp_n = C_lpK_q lp_n-1 + (1 - C_lp)K_q_n\n(low-pass-filtered k_q)\nC_lp = e^-2pi Delta t zeta_lp\n(low-pass-filter constant)\nzeta_lp\ntypically - 3 dB (low-pass-frequency cutoff)","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"From here on the LP subscript is dropped with the understanding that quantities such as alpha, K_alpha, q, and K_q denote filtered quantities. ","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"1.11a (calculated solely at first time step)\nk_alpha(M) = frac1(1 - M) + C_nalpha(M)M^2beta_M(A_1b_1 +A_2b_2)\n1.11b (calculated solely at first time step)\nk_q(M) = frac1(1-M) + C_nalpha(M)M^2beta_M(A_1b_1 + A_2b_2)\n1.10\nT_alpha(M) = 075 k_alpha(M)T_I\nT_q(M) = 075 k_q(M)T_I\n1.37\nT_f = fracT_f0sigma_1\n1.48\nT_v = fracT_v0sigma_3\n1.18 (Noncirculatory component... (of Normal force?) due to changes in alpha)\nC_n_alpha^nc(sM) = frac4T_alpha(M)M(K_alpha - K_alpha)\n(Deficiency function for C_n_alpha^nc(sM)) \nK_alpha_n = K_alpha_n-1 textexpleft(-fracDelta tT_alpha(M) right) + (K_alpha_n - K_alpha_n-1)textexpleft(- fracDelta t2T_alpha(M) right)\n1.19 (Noncirculatory component (of Normal force?) due to changes if q)\nC_n_q^nc(sM) = - fracT_q(M)M(K_q_n - K_q_n)\nK_q_n = K_q_n-1textexpleft(- fracDelta tT_q(M) right) + (K_q_n - K_q_n-1)textexpleft(- fracDelta t2 T_q(M) right)\n1.17 (Noncirculatory component (of normal force?) via superposition)\nC_n_alpha q^nc(s M) = C_n_alpha^nc(sM) + C_n_q^nc(sM)\nNote that the equation is stating that these normal force components are functions of s and M. \n1.15 (Update States 1 and 2)\nX_\n{1n} = X{1{n-1}}\\text{exp}(-b1\\betaM^2\\Delta s) + A1 \\text{exp}(-b1\\betaM^2\\Delta s/2)\\Delta \\alpha_n $\nX_\n{2n} = X{2{n-1}}\\text{exp}(-b2\\betaM^2\\Delta s) + A2 \\text{exp}(-b2\\betaM^2\\Delta s/2)\\Delta \\alpha_n $\n1.14 (Effective angle of attack)\nalpha_e_n(s M) = (alpha_n - alpha_0) - X_1_n(Delta s) - X_2_n(Delta S)\nI'm assuming that the equation is saying that the two states are functions of Delta s. \n1.13 (Circulatory component (normal force?) by the lumped approach)\nC_n_alpha q^C(s M) = C_nalpha^C(sM)alpha_e\n==I don't think C_nalpha^C(sM) has been defined.==\nEQ 1.12 C_nalpha^C(sM) = fracC_nalpha(M)beta_M \n1.26 (A_5 = 1 and b_5 = 5)\nK_q_n = K_q_n-1textexpleft(-b_5 beta_M^2 Delta sright) + A_5Delta q_n textexpleft(- b_5 beta_M^2 Delta s2 right)\n1.25 (Circulatory component (moment?))\nC_m_q^c(s M) = - fracC_nalpha(M)16beta_M (q - K_q)fraccU\n1.20 (total normal force under attached conditions)\nC_n^pot = C_n_alphaq^C(sM) + C_n_alphaq^nc(sM)\n==In the equation (1.20) they appeared to have dropped a negative that appears in the second term. I'll need to pay attention to this.==\n1.29 (other noncirculatory component)\nC_m_q^nc(sM) = -frac7T_i12Mleft(k_mq(M)right)^2 (K_q - K_q)\nk_mq(M) = frac715(1-M) + 15 C_nalpha(M)A_5 b_5 beta_M M^2\nK_q_n = K_q_n-1textexpleft(- fracDelta t(k_mq(M))^2 T_I right) + (K_q_n - K_q_n-1)textexpleft(- fracDelta t(k_mq(M))^2 T_I right)\n==Why are we calculating these portions of the moment?==\n1.21 (Chordwise force)\nC_C^pot = C_n^potctexttan(alpha_e + alpha_0)\n1.35 (Lagged Circulatory normal force (boundary layer response))\nC_n = C_n^pot - D_p\nD_\n{pn} = D{p{n-1}}\\text{exp}\\left(- \\frac{\\Delta s}{Tp}\\right) + (C{n{n}}^{pot}-C{n{n-1}}^{pot}\\text{exp}\\left(-\\frac{\\Delta s}{2T_p}\\right) $\n1.34 (an effective AOI)\nalpha_f = fracC_nC_nalpha^c(sM) + alpha_0\n1.33 (TE Separation point distance (from LE in percentage chord))","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":" f = begincases\n    1 - 03 textexpleft(fracalpha - alpha_1S_1right) text if  alpha_0 leq alpha leq alpha_1 \n    1 - 03 textexpleft(fracalpha_2 - alphaS_3right) text if  alpha_2 leq alpha leq alpha_0 \n    004 + 066textexpleft(fracalpha_1 - alphaS_2right) text if  alpha  alpha _1 \n    004 + 066 textexpleft(fracalpha - alpha_2S_4right) text if  alpha  alpha_2\n    endcases","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"S_1\nand S_2 are best-fit constants that define the abruptness of the static stall. \nalpha_1\nis the angle of attack @ f=07 for alphageqalpha_0. \nalpha_2\nis the angle of attack @ f=07 for alphaalpha_0. \n1.36 (f that accounts for delays in the boundary layer)\nf = f - D_f\nf = f(alpha_f)\nf\ncan be derived from a direct lookup table of static airfoil data reversing EQ 1.32. In fact, two values of f could be calculated: one for C_n(f_n) and one for C_c(f_c). \nD_f_n = D_f_n-1 textexpleft(- fracDelta sT_fright) + (f_n - f_n-1)textexpleft(- fracDelta s2T_fright)\n1.38 or 1.39\n(1.38) C_n^fs = C_n_alphaq^nc(s M) + C_n_alphaq^c(sM)left(frac1 + sqrtf2right)^2\n(1.39)\nGonzalez (2014) correction. \n1.49 or 1.50\n(1.49) C_V = C_nalpha^c(sM)alpha_eleft(1 - frac1 + sqrtf2right)^2\n(1.50)\nGonzalez (2014) correction.\n1.47 or 1.52\n(1.47) C_n_n^v = C_n_n-1^v textexpleft(- fracDelta sT_vright) + (C_V_n - C_V_n-1)textexpleft(- fracDelta s2T_vright)\nNote that C_n^v is not allowed to have a sign opposite to that of C_n^fs. \n(1.52)\nsome correction","category":"page"},{"location":"beddoesleishman_theory/#Update-Other-States","page":"Beddoes-Leishman Theory","title":"Update Other States","text":"","category":"section"},{"location":"beddoesleishman_theory/#Leading-Edge-Separation","page":"Beddoes-Leishman Theory","title":"Leading Edge Separation","text":"","category":"section"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"if C_n  C_n1 implies (C_nC_n2 for alphaalpha_0) \nLESF = true #LE separation can occur\nelse\nLESF = false #Reattacment can occur\nend","category":"page"},{"location":"beddoesleishman_theory/#Trailing-Edge-Separation","page":"Beddoes-Leishman Theory","title":"Trailing Edge Separation","text":"","category":"section"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"if f_t  f_t-1\nTESF = true #TE separation in progress\nelse\nTESF = false #TE reattachment in progress\nend","category":"page"},{"location":"beddoesleishman_theory/#Vortex-advection","page":"Beddoes-Leishman Theory","title":"Vortex advection","text":"","category":"section"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"if 0tau_vleq 2T_vl\nVRTX = true #Vortex advection in progress\nelse\nVRTX = false #Vortex is in wake\nend","category":"page"},{"location":"beddoesleishman_theory/#Vortex-Position-Reset","page":"Beddoes-Leishman Theory","title":"Vortex Position Reset","text":"","category":"section"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"if tau_v geq 1 + fracT_shT_vl and LESF = true\ntau_v=0\nend","category":"page"},{"location":"beddoesleishman_theory/#T_f-Modifications","page":"Beddoes-Leishman Theory","title":"T_f Modifications","text":"","category":"section"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"eq 1.37","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"T_f = T_f0sigma_1 ","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"sigma_1","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"is initilized at 1.  Delta_alpha 0 = alpha - alpha_0","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"if TESF == true #(Separation)\n    if K_alpha Delta_alpha0 < 0\n        sigma_1 = 2 #(Accelerate separation point movement)\n    else\n        if LESF == false\n            sigma_1 = 1 #(LE separation can occur)\n        else\n            if fpp_nm1 <= 0.7 \n                sigma_1 = 2 #(accelerate separation point movement if separation is occuring )\n            else\n                sigma_1 = 1.75\n            end\n        end\n    end\nelse #(reattachment (`TESF==false`))\n    if LESF == false\n        sigma_1 = 0.5 #(Slow down reattachment)\n    elseif VRTX == true  && 0 <= tau_v <= Tvl\n        sigma_1 = 0.25 #(No flow reattachment if vortex shedding is in progress)\n    elseif K_alpha*Delta_alpha > 0\n        sigma_1 = 0.75\n    end \nend","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"Apparently Aerodyn uses a \"simpler\" version. ","category":"page"},{"location":"beddoesleishman_theory/#T_v-Modifications","page":"Beddoes-Leishman Theory","title":"T_v Modifications","text":"","category":"section"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"simga3 = 1\n\nif Tvl <= Tau_v <= 2*Tvl>\n    sigma3 = 3 #Postshedding\n    if TESF== false\n        sigma3 = 4 #Accelerate vortex lift decay\n        if VRTX == true && 0 <= Tau_v <= Tvl\n            if K_alpha*Delta_alpha0 < 0\n                sigma3 = 2 #Accelerate vortex lift decay\n            else\n                sigma3 = 1 #default\n            end\n        end\n    end\nelse\n    if K_alpha*Delta_alpha0 < 0\n        sigma3 = 4 #vortex lift must decay fast\n    end\nend\n\nif TESF == false && K_q*Delta_alpha0 < 0 #Note that it's Kq and not K_alpha\n    sigma3 = 1 #Default\nend\n","category":"page"},{"location":"beddoesleishman_theory/#Calculate-Output","page":"Beddoes-Leishman Theory","title":"Calculate Output","text":"","category":"section"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"==For the first time step, outputs are determined by static lookup tables==","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"Same as Update Discrete States Plus","category":"page"},{"location":"beddoesleishman_theory/","page":"Beddoes-Leishman Theory","title":"Beddoes-Leishman Theory","text":"1.53 (Total normal force)\nC_n = C_n^fs + C_n^v\nDoes this somehow include a switch between separated flow and attached flow? Or do the components changed based on that? \n1.55 (Chordwise Force)\nC_c = C_c^fs + C_n^v texttan(alpha_e)left(1 - fractau_vT_vlright)\nIn the current release texttan(alpha_e)approx alpha_e\n1.2 (Lift and Drag)\nC_l = C_n cos(alpha) + C_csin(alpha)\nC_d = Cnsin(alpha) - C_ccos(alpha) + C_d_0\n1.58 or 1.59 (Minnema) or 1.60 (Gonzalez) (pitching moment)\n(1.58) C_m = C_m0 - C_n_alphaq^c(sM)(hatx_cp - 025) + C_m_q^c(sM) + C_m_alpha^nc(sM) + C_m_q^nc(sM) + C_m^v\n(1.59)\n(1.60)","category":"page"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"1) @article{Leishman1989,\n\tAuthor = {J. G. Leishman and T. S. Beddoes},\n\tJournal = {Forum of the American Helicopter Society},\n\tTitle = {A Semi-Emprical Model for Dynamic Stall},\n\tVolume = {42},\n\tYear = {1989}}\n\n2) @article{Hansen2004,\n\tAuthor = {Morten Hartvig Hansen and Mac Gaunaa and Helge Aa. Madsen},\n\tJournal = {Riso National Laboratory},\n\tTitle = {A Beddoes-Leishman type dynamic stall model in state-space and indicial formulations},\n\tYear = {2004}}\n\n3) @techreport{Damiani2019,\n\tAuthor = {Rick Damiani and Greg Hayman},\n\tInstitution = {NREL},\n\tTitle = {The Unsteady Aerodynamics Module for FAST 8},\n\tYear = {2019}}\n","category":"page"},{"location":"riso_theory/#Risø-Theory","page":"Risø Theory","title":"Risø Theory","text":"","category":"section"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"The Risø model<sup>2</sup> is a simplified version of the Beddoes-Leishman model, designed specifically for wind turbines.","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"It has four states. The four states are:","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"Variable Name Comments\nx_1  Using Theodorsen theory, we can come up with two ODEs to describe the change in the wake.\nx_2  The first state and second state model these changes. One is for high frequency changes while the other is for low frequency changes.\nx_3 = C_L^p Delayed coefficient of lift due to pressure. Delayed unsteady attached lift coefficient. A simple time lag (first order lag) between the pressure field and the lift.\nx_4 = f Delayed seperation point? Unsteady seperation point. This should range (0,1).","category":"page"},{"location":"riso_theory/#State-Rate-Equations","page":"Risø Theory","title":"State Rate Equations","text":"","category":"section"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"beginaligned\ndotx_1 = - fracx_1T_uleft(b_1 + fraccdotU2U^2right) + fracb_1A_1 alpha_34T_u \ndotx_2 = - fracx_2T_uleft(b_2 + fraccdotU2U^2right) + fracb_2A_2 alpha_34T_u \ndotx_3 = - fracx_3T_p + frac1T_pleft(fracpartial C_lpartial alpha(alpha_E - alpha_0) + pi T_u dotalpha right) \ndotx_4 = - fracx_4T_f = frac1T_ff^stleft(alpha_fright)\nendaligned","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"where x_i are the states of the model, T_x are time constants, A_i and b_i are airfoil specific constants describing the response of the airfoil, U is the freestream velocity, alpha_34 is the angle of attack the three-quarter point, fracpartial C_lpartial alpha is the slope of the static lift curve in the linear region, alpha_E is the equivalent angle of attack, f^st is the seperation point function, and alpha_f is the delayed angle of attack (this is something that I made up to make the notation a little clearer. ). ","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"A couple of notes: first, T_u is calculated, whereas the other two time constants are specific for the airfoil (although several authors have said that they are pretty constant from airfoil to airfoil... but at the same time, those authors give different values for the time constant than the other authors... so it seems pretty arbitrary). Second, variables with a dot above it (dotU for instance) indicate the derivative with respect to time. Third, recognize that U and alpha are both functions of time. Fourth, I just use the angle of attack for alpha_34... which appears to work, but Hansen's paper specifically seperates from the geometric angle of attack.","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"Now I'm going to dive into a bunch of the functions. ","category":"page"},{"location":"riso_theory/#First-Time-Constant","page":"Risø Theory","title":"First Time Constant","text":"","category":"section"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"T_u = fracc2U","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"where c is the chord, and U is the freestream velocity. Since U is a function of time, then this time constant isn't really constant...","category":"page"},{"location":"riso_theory/#Lift-Curve-Slope","page":"Risø Theory","title":"Lift Curve Slope","text":"","category":"section"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"Hansen gives an equation for fracpartial C_lpartial alpha, which makes it so that f^st never goes over 1.... which is just a max equation... but I feel like it is a lame excuse and it is more accurate if you use a value that matches the majority of the linear region. I feel like there should be a better way to define f^st so it never goes over 1, and plays nicely with optimization. At the same time he says: \"However, in cases where lift curves are provided directly from measurements, or CFD computations, it can be necessary to use linear regression to determine a linear lift curve in a range of lower angles of attack with fully attached flow.\" DG has said several times that it is fairly common to choose constants that recreate the static lift curve. ","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"fracpartial C_lpartial alpha = textmaxleft(fracC_l^st(alpha)(alpha - alpha_0)right)","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"where C_l^st is the lift from the static lift curve, and alpha_0 is the zero lift angle of attack. You'll frequently see fracpartial C_lpartial alphaleft(alpha - alpha_0right), which is just the inviscid lift. Note that in his paper, Hansen denotes the linear lift curve slope as C_Lalpha. ","category":"page"},{"location":"riso_theory/#Equivalent-Angle-of-Attack","page":"Risø Theory","title":"Equivalent Angle of Attack","text":"","category":"section"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"alpha_E = alpha_34(1 - A_1 - A_2) + x_1 + x_2","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"It's an equivalent angle of attack. Basically from what I understand is it is a weighting of what we expect the angle of attack to be from the geometric angle of attack and what the wake currently looks like.","category":"page"},{"location":"riso_theory/#Seperation-Point-Function","page":"Risø Theory","title":"Seperation Point Function","text":"","category":"section"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"Here is a function that gives me a little bit of problem:","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"f^st(alpha) = left(2 sqrtfracC_l^stC_l^i -1right)^2","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"where C_l^i is the inviscid lift coefficient. The inviscid lift coefficent, as previously mentioned, is simply: C_l^i(alpha) = fracpartial C_lpartial alpha (alpha - alpha_0). However, the value of this should always be on the range (0,1). It should be equal to 1 when the flow is fully attached (in the linear region), and 0 when the angle of attack is outside the angles of full seperation. Hansen defines the angles of full seperation as when the static lift is one-fourth the value of the inviscid lift:","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"C_l^st(alpha^pm fs) = leftfracpartial C_lpartial alphafrac(alpha^pm fs - alpha_0)4right","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"What I currently have implemented for the seperation pooint function is: ","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"f^st(alpha)=begincases\n          0 quad textif   alphaalpha^-fs  alphaalpha^+fs \n          1 quad textif   f^st  1    f^st = textNaN \n          left(2 sqrtfracC_l^stC_l^i -1right)^2 quad  textelse\n     endcases","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"Which isn't my favorite. But it works. ","category":"page"},{"location":"riso_theory/#Other-Time-Constants","page":"Risø Theory","title":"Other Time Constants","text":"","category":"section"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"T_f","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"describes the time lag in the boundary layer. ","category":"page"},{"location":"riso_theory/#Equations-for-the-Coefficients","page":"Risø Theory","title":"Equations for the Coefficients","text":"","category":"section"},{"location":"apireference/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"As you will see in the Code Outline and getting started, most of the code in this package revolves around creating instances of model, which have been formatted to be solved. There are some convenience functions for creating these structs. There are also some functions for parsing solutions. another change. another change. ","category":"page"},{"location":"apireference/#Airfoils","page":"API Reference","title":"Airfoils","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"DynamicStallModels.Airfoil","category":"page"},{"location":"apireference/#DynamicStallModels.Airfoil","page":"API Reference","title":"DynamicStallModels.Airfoil","text":"Airfoil(polar::Array{TF, 2}, cl::Tfit, cd::Tfit, cm::Tfit, dcldalpha::TF, alpha0::TF, alphasep::Array{TF, 1}, A::Array{TF, 1}, b::Array{TF, 1}, T::Array{TF, 1})\n\nA struct to hold all of the airfoil polars, fits, and dynamic coefficients. \n\nInputs\n\npolar - A matrix of floats describing the airfoil polar. This includes the angle of attack (radians), and coefficients of lift, drag, and moment. \ncl - A fit of the coefficient of lift as a function of the angle of attack (radians). \ncd - A fit of the coefficient of drag as a function of the angle of attack (radians). \ncm - A fit of the coefficient of moment as a function of the angle of attack (radians). \ndcldalpha - The lift curve slope in the linear region (1/radians). Typically near 2 pi. \nalpha0 - The zero lift angle of attack (radians). \nalphasep - A vector of floats holding the angles of attack at which flow fully seperates from the airfoil. In order from least to greatest. \nA - A vector of floats holding the A dynamic constants for the airfoil. \nb - A vector of floats holding the b dynamic constants for the airfoil. \nT - A vector of floats holding the time constants for the airfoil. \n\n\n\n\n\n","category":"type"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"simpleairfoil","category":"page"},{"location":"apireference/#DynamicStallModels.simpleairfoil","page":"API Reference","title":"DynamicStallModels.simpleairfoil","text":"simpleairfoil(polar::Array{TF, 2})\n\nA function that takes a simple airfoil polar to make a dynamic airfoil. The function assumes that the lift curve slope is 2 pi, that the zero lift angle of attack is zero, and uses AeroDyn's default dynamic airfoil coefficients. The seperation angles of attack are the angles of attack at the minimum and maximum lift.\n\nInputs\n\npolar - A simple airfoil polar including alpha, lift, and drag.\n\nOutputs\n\nAirfoil\n\n\n\n\n\n","category":"function"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"airfoil","category":"page"},{"location":"apireference/#DynamicStallModels.airfoil","page":"API Reference","title":"DynamicStallModels.airfoil","text":"airfoil(polar::Array{TF, 2}; A::Array{TF, 1} = [0.3, 0.7], b::Array{TF, 1} = [0.14, 0.53], T::Array{TF, 1} = [1.7, 3.0])\n\nA slightly more complex version of simpleairfoil. Takes a polar and numerically finds some characteristics. \n\nInputs\n\npolar - A matrix of floats describing the airfoil polar. This includes the angle of attack (radians), and coefficients of lift, drag, and moment.\nA - A vector of floats holding the A dynamic constants for the airfoil. \nb - A vector of floats holding the b dynamic constants for the airfoil. \nT - A vector of floats holding the time constants for the airfoil. \n\nOutputs\n\nAirfoil\n\n\n\n\n\n","category":"function"},{"location":"apireference/#Beddoes-Leishman","page":"API Reference","title":"Beddoes-Leishman","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"BeddoesLeishman","category":"page"},{"location":"apireference/#DynamicStallModels.BeddoesLeishman","page":"API Reference","title":"DynamicStallModels.BeddoesLeishman","text":"BeddoesLeishman(detype::DEType, n::Int, airfoils::Array{Airfoil, 1})\n\nThe Beddoes-Leishman model struct. It stores airfoil data for every section to be simulated. It can be used as a method to return updated states or state rates depending on it's DEType. \n\nInputs\n\ndetype - The type of model it is, Functional(), Iterative(), or Indicial().\nn - The number of sections to be simulated. \nairfoils - A vector of Airfoil structs, one corresponding to each section to be simulated. \n\n\n\n\n\n","category":"type"},{"location":"apireference/#Larsen","page":"API Reference","title":"Larsen","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"Larsen","category":"page"},{"location":"apireference/#DynamicStallModels.Larsen","page":"API Reference","title":"DynamicStallModels.Larsen","text":"Larsen(detype::DEType, n::Int, airfoils::Array{Airfoil, 1})\n\nThe Larsen model struct. It stores airfoil data for every section to be simulated. It can be used as a method to return updated states or state rates depending on it's DEType. \n\nInputs\n\ndetype - The type of model it is, Functional(), Iterative(), or Indicial().\nn - The number of sections to be simulated. \nairfoils - A vector of Airfoil structs, one corresponding to each section to be simulated. \n\n\n\n\n\n","category":"type"},{"location":"apireference/#Onera","page":"API Reference","title":"Onera","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"Onera","category":"page"},{"location":"apireference/#DynamicStallModels.Onera","page":"API Reference","title":"DynamicStallModels.Onera","text":"Onera(detype::DEType, n::Int, airfoils::Array{Airfoil, 1})\n\nThe Onera model struct. It stores airfoil data for every section to be simulated. It can be used as a method to return updated states or state rates depending on it's DEType. \n\nInputs\n\ndetype - The type of model it is, Functional(), Iterative(), or Indicial().\nn - The number of sections to be simulated. \nairfoils - A vector of Airfoil structs, one corresponding to each section to be simulated. \n\n\n\n\n\n","category":"type"},{"location":"apireference/#Oye","page":"API Reference","title":"Oye","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"Oye","category":"page"},{"location":"apireference/#DynamicStallModels.Oye","page":"API Reference","title":"DynamicStallModels.Oye","text":"Oye(detype::DEType, n::Int, airfoils::Array{Airfoil, 1})\n\nThe Øye model struct. It stores airfoil data for every section to be simulated. It can be used as a method to return updated states or state rates depending on it's DEType. \n\nInputs\n\ndetype - The type of model it is, Functional(), Iterative(), or Indicial().\nn - The number of sections to be simulated. \nairfoils - A vector of Airfoil structs, one corresponding to each section to be simulated. \n\n\n\n\n\n","category":"type"},{"location":"apireference/#Risø","page":"API Reference","title":"Risø","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"Riso","category":"page"},{"location":"apireference/#DynamicStallModels.Riso","page":"API Reference","title":"DynamicStallModels.Riso","text":"Riso(detype::DEType, n::Int, airfoils::Array{Airfoil, 1})\n\nThe Risø model struct. It stores airfoil data for every section to be simulated. It can be used as a method to return updated states or state rates depending on it's DEType. \n\nInputs\n\ndetype - The type of model it is, Functional(), Iterative(), or Indicial().\nn - The number of sections to be simulated. \nairfoils - A vector of Airfoil structs, one corresponding to each section to be simulated. \n\n\n\n\n\n","category":"type"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"riso","category":"page"},{"location":"apireference/#DynamicStallModels.riso","page":"API Reference","title":"DynamicStallModels.riso","text":"riso(airfoils::Array{Airfoil, 1}; detype::DEType=Iterative())\n\nA convenience. constructor for the Risø model. \n\nInputs\n\nairfoils - A vector of Airfoil structs, one corresponding to each section to be simulated. \ndetype - The DEType of the model. Defaults to Iterative(). \n\n\n\n\n\n","category":"function"},{"location":"#DynamicStallModels.jl","page":"Introduction","title":"DynamicStallModels.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This package is a collection of different dynamic stall models. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Dynamic stall models included in this package: ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Beddoes-Leishman - State Space\nBeddoes-Leishman - Indicial\nBeddoes-Leishman - AeroDyn implementation\nRisø (Hansen 2004) - State Space\nRisø - Indicial\nLarsen\nOnera\nOye","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"To get started, add the package. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"pkg> add https://github.com/byuflowlab/DynamicStallModels.jl.git","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Then checkout the Getting Started page. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"warning: Warning - Lack of Validation\nAn important thing to note is the lack of validation. The Beddoes-Leishman implementations are very far from validated and likely still have bugs.  The Risø models perform much better. For attached conditions, the models perform as expected compare excellently to published data (see the validation section of theory (that has yet to be created)). In stall conditions, when actual stall occurs, the models do not perform as expected. We are unsure if it has something to do with our implementation, or due to a lack of information provided in the published paper. We were unable to find the operating conditions that Hansen did his simulations at, and so we assumed them. We were able to get a decent match by optimizing the dynamic coefficients, but they were much different than the ones Hansen provided.  The Onera model has been validated (The validation needs to be added). ","category":"page"},{"location":"#References","page":"Introduction","title":"References","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Please check our References page to see the original authors of content presented herein. ","category":"page"},{"location":"codeoutline/#Code-Outline","page":"Code Outline","title":"Code Outline","text":"","category":"section"},{"location":"codeoutline/","page":"Code Outline","title":"Code Outline","text":"Here I will outline the code and how it all fits together. In case you wanted to add something to this package. ","category":"page"},{"location":"riso_example/#Risø-Model","page":"Risø Model","title":"Risø Model","text":"","category":"section"}]
}
