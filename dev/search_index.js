var documenterSearchIndex = {"docs":
[{"location":"gettingstarted/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"The dynamic stall models are implemented in three ways: as a functional, an iterative, and in an indicial form. ","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Functional implementations create a struct that returns the state rates. This allows for easy solution using DifferentialEquations.jl. These functional implementations are designed to be passed a single set of parameters, p. Out of this set of parameters, several are functions, such as the freestream velocity. ","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Iterative implementations create a struct that returns the state rates as well, however they are not as easily solved by DifferentialEquations.jl. The input parameters are now all constant values, including the freestream velocity and angle of attack. This implementation is designed to be solved iteratively, meaning that for a given set of parameters, the states are updated for a single time step. The purpose of this type of implementation is for interfacing with other packages, specifically Rotors.jl. In the future, a function will be introduced that converts functions that describe environmental inputs into parameters, and then iterates through the solution of the model. ","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"The final implementation is an indicial formulation. Rather than providing a state space model to be solve, the model takes the environmental inputs and time step and calculates the states at the next time step. Several of the dynamic stall models included in this pakage were first developed in indicial form. ","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"We'll get started by using a functional implementation of the Risø model. Because we are using a functional implementation, we willl need our flow conditions as functions of time. We'll simulate a flat plate pitching in steady inflow. We'll look at a freestream velocity of 1 m/s, while the airfoil pitches plus or minus 1 degree (amplitude of 2) about 5 degrees. ","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"k = 0.2 #reduced frequency\nu = 1.0 #freestream velocity (m/s) \nc = 1.0 #Chord (m)\namplitude = 2\nshift = 5\n\nomega = k*2*u/c #Rate of oscillation\n\n### Prepare inputs\nU(t) = u #Freestream velocity as a function of time\nUdot(t) = 0.0 #Derivative of freestream velocity as a function of time\nalpha(t) = (amplitude*sin(omega*t) + shift)*(pi/180) #Angle of attack as a function of time (radians)\nalphadot(t) = (amplitude*omega*cos(omega*t)*(pi/180)) #Pitching rate as a function of time (radians)","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"At this point, we would normally read in an airfoil polar, however, since we are simulating a flat plate, we will use the inviscid solution for lift for a flat plate. ","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"\naoa = -pi:0.01:pi #Angle of Attack, (radians)\nlift = 2*pi.*(aoa) #Coefficient of lift\ndrag = zero(aoa) #Coefficient of drag, left zero for this demonstration. \npolar = hcat(aoa, lift, drag)\n\nA = [0.165, 0.335] #From the Hansen 2004 paper, for flat plate\nb = [0.0455, 0.3000] # \"\" \"\"\n\nTp = 3.0 # \"\" \"\" \nTf = 6.0 # \"\" \"\" \nT = [Tp, Tf]","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Now at this point, we'll store that information in an airfoil struct. ","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"using DynamicStallModels\n\nairfoils = [airfoil(polar; A, b, T)]","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"If we had more airfoils, we would simply add them to the airfoils array. ","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Now we'll create the Risø struct, which will be our ODE to solve. ","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"dsmodel = Riso(airfoils; detype=Functional())","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"And now we prepare to solve using DifferentialEquations.jl. Note the order of p below, this is the required order. If simulating more than one airfoil, the chord lengths would be concatonated. So p = vcat([U, Udot, alpha, alphadot], [c]).","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"using DifferentialEquations\nx0 = zeros(4) #Hansen 2004's suggest initial conditions.\nx0[3] = 1.0\n\np = [U, Udot, alpha, alphadot, c]\n\ntspan = (0.0, 80.0)\n\nprob = ODEProblem(dsmodel, x0, tspan, p)","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Now let's solve using DifferentialEquations. A function to parse the DifferentialEquations solution and calculate the coefficients of lift and drag has been provided. ","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"sol = solve(prob, dtmax=0.1)\n\nCl, Cd, t =  parsesolution(dsmodel, sol, p)","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Also if the user has a specific set of states they would like to analyze, they can extract the states on their own and use the provided functions to calculate the coefficients. ","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"### Unpack\nx = Array(sol)'\nt = sol.t\n\nnt = length(t)\n\nclvec = zeros(nt, dsmodel.n)\ncdvec = zeros(nt, dsmodel.n)\n### run through the time steps and calculate the dynamic lift and drag (based on the states)\nfor i = 1:nt\n    ti = t[i]\n    for j = 1:dsmodel.n\n        clvec[i,j], cdvec[i,j] = riso_coefficients(x[i,:], U(ti), alpha(ti), alphadot(ti), cvec[j], dsmodel.airfoils[j])\n    end\nend","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Here we use Plots.jl to visualize the lift and compare against the values given in Hansen's 2004 paper where the model was presented. Note that shown is Hansen's indicial solution, whereas here we solve the state space model, so minor differences exist. ","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"using Plots\nalphavec = alpha.(sol.t)\n\nexpdata = readdlm(\"./data/Hansen2004/figure8_flatplate/indicial.csv\", ',')\n\n\nclplt = plot(legend=:topleft, title=\"Cyclic Alpha\", yaxis=\"Cl\", xaxis=\"Alpha (deg)\")\nscatter!(expdata[:,1], expdata[:,2], lab=\"Hansen 2004\")\nplot!(alphavec.*(180/pi), Cl, lab=\"DSM - Riso\")\nplot!(alphavec.*(180/pi), linearlift.(alphavec), lab=\"Static\")\ndisplay(clplt)","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"riso_theory/#Risø-Theory","page":"Risø Theory","title":"Risø Theory","text":"","category":"section"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"The Risø model is a simplified version of the Beddoes-Leishman model, designed specifically for wind turbines. It has four states. The four states are:","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"Variable Name Comments\nx_1  Using Theodorsen theory, we can come up with two ODEs to describe the change in the wake.\nx_2  The first state and second state model these changes. One is for high frequency changes while the other is for low frequency changes.\nx_3 = C_L^p Delayed coefficient of lift due to pressure. Delayed unsteady attached lift coefficient. A simple time lag (first order lag) between the pressure field and the lift.\nx_4 = f Delayed seperation point? Unsteady seperation point. This should range (0,1).","category":"page"},{"location":"riso_theory/#State-Rate-Equations","page":"Risø Theory","title":"State Rate Equations","text":"","category":"section"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"beginaligned\ndotx_1 = - fracx_1T_uleft(b_1 + fraccdotU2U^2right) + fracb_1A_1 alpha_34T_u \ndotx_2 = - fracx_2T_uleft(b_2 + fraccdotU2U^2right) + fracb_2A_2 alpha_34T_u \ndotx_3 = - fracx_3T_p + frac1T_pleft(fracpartial C_lpartial alpha(alpha_E - alpha_0) + pi T_u dotalpha right) \ndotx_4 = - fracx_4T_f = frac1T_ff^stleft(alpha_fright)\nendaligned","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"where x_i are the states of the model, T_x are time constants, A_i and b_i are airfoil specific constants describing the response of the airfoil, U is the freestream velocity, alpha_34 is the angle of attack the three-quarter point, fracpartial C_lpartial alpha is the slope of the static lift curve in the linear region, alpha_E is the equivalent angle of attack, f^st is the seperation point function, and alpha_f is the delayed angle of attack (this is something that I made up to make the notation a little clearer. ). ","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"A couple of notes: first, T_u is calculated, whereas the other two time constants are specific for the airfoil (although several authors have said that they are pretty constant from airfoil to airfoil... but at the same time, those authors give different values for the time constant than the other authors... so it seems pretty arbitrary). Second, variables with a dot above it (dotU for instance) indicate the derivative with respect to time. Third, recognize that U and alpha are both functions of time. Fourth, I just use the angle of attack for alpha_34... which appears to work, but Hansen's paper specifically seperates from the geometric angle of attack.","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"Now I'm going to dive into a bunch of the functions. ","category":"page"},{"location":"riso_theory/#First-Time-Constant","page":"Risø Theory","title":"First Time Constant","text":"","category":"section"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"T_u = fracc2U","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"where c is the chord, and U is the freestream velocity. Since U is a function of time, then this time constant isn't really constant...","category":"page"},{"location":"riso_theory/#Lift-Curve-Slope","page":"Risø Theory","title":"Lift Curve Slope","text":"","category":"section"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"Hansen gives an equation for fracpartial C_lpartial alpha, which makes it so that f^st never goes over 1.... which is just a max equation... but I feel like it is a lame excuse and it is more accurate if you use a value that matches the majority of the linear region. I feel like there should be a better way to define f^st so it never goes over 1, and plays nicely with optimization. At the same time he says: \"However, in cases where lift curves are provided directly from measurements, or CFD computations, it can be necessary to use linear regression to determine a linear lift curve in a range of lower angles of attack with fully attached flow.\" DG has said several times that it is fairly common to choose constants that recreate the static lift curve. ","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"fracpartial C_lpartial alpha = textmaxleft(fracC_l^st(alpha)(alpha - alpha_0)right)","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"where C_l^st is the lift from the static lift curve, and alpha_0 is the zero lift angle of attack. You'll frequently see fracpartial C_lpartial alphaleft(alpha - alpha_0right), which is just the inviscid lift. Note that in his paper, Hansen denotes the linear lift curve slope as C_Lalpha. ","category":"page"},{"location":"riso_theory/#Equivalent-Angle-of-Attack","page":"Risø Theory","title":"Equivalent Angle of Attack","text":"","category":"section"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"alpha_E = alpha_34(1 - A_1 - A_2) + x_1 + x_2","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"It's an equivalent angle of attack. Basically from what I understand is it is a weighting of what we expect the angle of attack to be from the geometric angle of attack and what the wake currently looks like.","category":"page"},{"location":"riso_theory/#Seperation-Point-Function","page":"Risø Theory","title":"Seperation Point Function","text":"","category":"section"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"Here is a function that gives me a little bit of problem:","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"f^st(alpha) = left(2 sqrtfracC_l^stC_l^i -1right)^2","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"where C_l^i is the inviscid lift coefficient. The inviscid lift coefficent, as previously mentioned, is simply: C_l^i(alpha) = fracpartial C_lpartial alpha (alpha - alpha_0). However, the value of this should always be on the range (0,1). It should be equal to 1 when the flow is fully attached (in the linear region), and 0 when the angle of attack is outside the angles of full seperation. Hansen defines the angles of full seperation as when the static lift is one-fourth the value of the inviscid lift:","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"C_l^st(alpha^pm fs) = leftfracpartial C_lpartial alphafrac(alpha^pm fs - alpha_0)4right","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"What I currently have implemented for the seperation pooint function is: ","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"f^st(alpha)=begincases\n          0 quad textif   alphaalpha^-fs  alphaalpha^+fs \n          1 quad textif   f^st  1    f^st = textNaN \n          left(2 sqrtfracC_l^stC_l^i -1right)^2 quad  textelse\n     endcases","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"Which isn't my favorite. But it works. ","category":"page"},{"location":"riso_theory/#Other-Time-Constants","page":"Risø Theory","title":"Other Time Constants","text":"","category":"section"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"T_f","category":"page"},{"location":"riso_theory/","page":"Risø Theory","title":"Risø Theory","text":"describes the time lag in the boundary layer. ","category":"page"},{"location":"riso_theory/#Equations-for-the-Coefficients","page":"Risø Theory","title":"Equations for the Coefficients","text":"","category":"section"},{"location":"apireference/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"As you will see in the Code Outline and getting started, most of the code in this package revolves around creating instances of model, which have been formatted to be solved. There are some convenience functions for creating these structs. There are also some functions for parsing solutions. another change. another change. ","category":"page"},{"location":"apireference/#Airfoils","page":"API Reference","title":"Airfoils","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"DynamicStallModels.Airfoil","category":"page"},{"location":"apireference/#DynamicStallModels.Airfoil","page":"API Reference","title":"DynamicStallModels.Airfoil","text":"Airfoil(polar, cl, cd, cm, dcldalpha, alpha0, alphasep, A, b, T)\n\nInputs\n\npolar::Array{TF, 2} - A matrix of floats describing the airfoil polar. This includes the angle of attack (radians), and coefficients of lift, drag, and moment. \ncl::Tfit - A fit of the coefficient of lift as a function of the angle of attack (radians). \ncd::Tfit - A fit of the coefficient of drag as a function of the angle of attack (radians). \ncm::Tfit - A fit of the coefficient of moment as a function of the angle of attack (radians). \ndcldalpha::TF - The lift curve slope in the linear region (1/radians). Typically near 2 pi. \nalpha0::TF - The zero lift angle of attack (radians). \nalphasep::Array{TF, 1} - A vector of floats holding the angles of attack at which flow fully seperates from the airfoil. In order from least to greatest. \nA::Array{TF, 1} - A vector of floats holding the A dynamic constants for the airfoil. \nb::Array{TF, 1} - A vector of floats holding the b dynamic constants for the airfoil. \nT::Array{TF, 1} - A vector of floats holding the time constants for the airfoil. \n\n\n\n\n\n","category":"type"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"simpleairfoil","category":"page"},{"location":"apireference/#DynamicStallModels.simpleairfoil","page":"API Reference","title":"DynamicStallModels.simpleairfoil","text":"simpleairfoil(polar)\n\nA function that takes a simple airfoil polar to make a dynamic airfoil. This function makes some gross assumptions.\n\nInputs\n\npolar::Array{TF, 2} - A simple airfoil polar including alpha, lift, and drag.\n\nOutputs\n\nAirfoil\n\nNotes\n\nThe function assumes that the lift curve slope is 2 pi, that the zero lift angle of attack is zero, and uses AeroDyn's default dynamic airfoil coefficients. The seperation angles of attack are the angles of attack at the minimum and maximum lift. \n\n\n\n\n\n","category":"function"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"airfoil","category":"page"},{"location":"apireference/#DynamicStallModels.airfoil","page":"API Reference","title":"DynamicStallModels.airfoil","text":"airfoil(polar; A = [0.3, 0.7], b = [0.14, 0.53], T = [1.7, 3.0])\n\nA slightly more complex version of simpleairfoil. Takes a polar and numberically finds some characteristics. \n\nInputs\n\npolar::Array{TF, 2}\nA::Array{TF, 1}\nb::Array{TF, 1}\nT::Array{TF, 1}\n\nOutputs\n\nAirfoil\n\n\n\n\n\n","category":"function"},{"location":"apireference/#Risø","page":"API Reference","title":"Risø","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"Riso","category":"page"},{"location":"apireference/#DynamicStallModels.Riso","page":"API Reference","title":"DynamicStallModels.Riso","text":"Riso(detype, n, airfoils)\n\n\n\n\n\n","category":"type"},{"location":"#DynamicStallModels.jl","page":"Introduction","title":"DynamicStallModels.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This package is a collection of different dynamic stall models. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Dynamic stall models included in this package: ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Beddoes-Leishman - State Space\nBeddoes-Leishman - Indicial\nBeddoes-Leishman - AeroDyn implementation\nRisø (Hansen 2004) - State Space\nRisø - Indicial\nLarsen\nOnera\nOye","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"To get started, add the package. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"pkg> add https://github.com/byuflowlab/DynamicStallModels.jl.git","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Then checkout the Getting Started page. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"warning: Warning - Lack of Validation\nAn important thing to note is the lack of validation. The Beddoes-Leishman implementations are very far from validated and likely still have bugs.  The Risø models perform much better. For attached conditions, the models perform as expected compare excellently to published data (see the validation section of theory (that has yet to be created)). In stall conditions, when actual stall occurs, the models do not perform as expected. We are unsure if it has something to do with our implementation, or due to a lack of information provided in the published paper. We were unable to find the operating conditions that Hansen did his simulations at, and so we assumed them. We were able to get a decent match by optimizing the dynamic coefficients, but they were much different than the ones Hansen provided.  The Onera model has been validated (The validation needs to be added). ","category":"page"},{"location":"codeoutline/#Code-Outline","page":"Code Outline","title":"Code Outline","text":"","category":"section"},{"location":"codeoutline/","page":"Code Outline","title":"Code Outline","text":"Here I will outline the code and how it all fits together. In case you wanted to add something to this package. ","category":"page"},{"location":"riso_example/#Risø-Model","page":"Risø Model","title":"Risø Model","text":"","category":"section"}]
}
